---
dg-publish: true
---
1. 生成4096 bit RSA公钥私钥
2. 生成4096 bit AES密钥
3. 根据AES密钥加密数据
4. 使用RSA公钥加密AES密钥
5. 发送加密的AES密钥
6. 发送AES加密后的数据
7. 接收加密的AES密钥
8. 使用RSA私钥解密AES密钥
9. 接收AES加密后的数据
10. 使用AES密钥解密数据

```mermaid
graph LR
    AES1[AES加密]
    AES2[AES解密]
    B[加密数据]
    E[加密AES]

    AES1 -->| | B
    B --> | | AES2
    AES1 --> |RSA公钥加密| E
    E -->|RSA私钥解密| AES2

```

### 生成RSA公钥私钥
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

def generate_rsa_keypair():
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=4096,
        backend=default_backend()
    )

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    )

    public_key = private_key.public_key()
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    return private_pem, public_pem

private_key, public_key = generate_rsa_keypair()

# 打印私钥和公钥
print("Private Key:")
print(private_key.decode('utf-8'))

print("\nPublic Key:")
print(public_key.decode('utf-8'))

```
### 公钥加密数据
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding

def encrypt_data(data, public_key_pem):
    # 从PEM格式的公钥字符串加载公钥对象
    public_key = serialization.load_pem_public_key(public_key_pem, backend=default_backend())

    # 加密数据
    ciphertext = public_key.encrypt(
        data.encode('utf-8'),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    return ciphertext

# 假设你已经有一个4096位的RSA公钥
public_key_pem = """-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwDDe1AhtAt9j7MFXaR/6
0OILNLklRGeQKRgGcMGqfl1Qxf8DlOv45rE2sxdysBmNTNQtRO6QdsTjOgA2Re2O
sKFXaOwV0KtxZapMQvPC/8N8YRXA4f2/iFm2nAsaYwbyGtRRuFOdRRwr6K6xDzvH
LuEvKqKLjt/hWjmt9cH+jTh0id0p6k1oNX5BegYiPtzVm6PKo8QonqTrMzvhmCfM
4Uhq7Ik/EowAcYrhLBn8kS2GOn6sHpCl6doM9CJ1oWyeMXk2iG/KotANlIenURSD
fgPR2tVWfRpJbZlKHrZj9B2Vfy12J7hIIn8dStGJhG/pMDSlJowpl26QKjIdWVcJ
hxAvqhx/2c5oI7yY/0eMZ3IyR+KGmRqkylajr+lmGR31qlz+VrK5rHlkRrnoK8TJ
/b/rki2R/a7OHlbfWJYm5trsq/t6hEM5X/aV5efwFNoOJ06sTd7NWcMXvsMTY0P7
yT9A2OoH78BjlaLwv5k4Dm1F9tXQaV4aRWX3AXv1lz9sy5yrxVY2pWhxNlUwTCXz
J7mMNt0ybrlM8lRQcJWuU1WEg4bFs2/jZ94mSiKLstGRRHbduZpU7eY+WeB12hKF
c0zENxFp0MC7dPYbrMZ9EymHxRlrL2zql7AKkmW/5fBUrrBX2yUP7YFqtWsCAwEA
AQ==
-----END PUBLIC KEY-----"""

# 要加密的数据
data_to_encrypt = "Hello, RSA Encryption!"

# 加密数据
encrypted_data = encrypt_data(data_to_encrypt, public_key_pem)

# 打印加密后的数据
print("Encrypted Data:")
print(encrypted_data.hex())

```
### 私钥解密数据
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding

def decrypt_data(encrypted_data, private_key_pem):
    # 从PEM格式的私钥字符串加载私钥对象
    private_key = serialization.load_pem_private_key(private_key_pem, password=None, backend=default_backend())

    # 解密数据
    decrypted_data = private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    return decrypted_data.decode('utf-8')

# 假设你已经有一个4096位的RSA私钥
private_key_pem = """-----BEGIN PRIVATE KEY-----
MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDAN97QIbQLfY+z
BV2kf+tDiCzS5JURnkCkYBnDBqn5dUMX/A5Tr+OaxNrMXcrAZjUzULUToR2xOM6A
DZF7Y6woVdo7BXQq3FlqkxC88L/w3xhFcDh/b+IWbacCxpjBvIa1FG4U51FHCvos
QPO8cu4S8qoouO3+FaOa31wf6NOHSHJ3SnpNaDV+QF6BiI+3NWbo8qjxCiepOszO
+GYJ8zhSGrsiT8SjABxiuEsGfyRLYY6fqwenoKXp2gz0InWhbJ4xeTaIb8qi0A2U
h6dRFIN+A9Ha1VZ9GkltmUoetmP0HZV/LXYnuEgifx1K0YmEb+kwNKUmjCmXbpAq
Mh1ZVwknFAC+qHH/ZzmgjvJj/R4xncjJH4oaZGqTKVqOv6WYZHfWqXP5WsrmseW
RGuegrxMn9v+uSLZH9rs4eVt9Ylibm2uyr+3qEQzlf9pXl5/AU2g4nTqxN3s1Zw
xe+wxNjQ/vJP0DY6gfvwGOWi8L+ZOA5tRfbV0GlXhpFZfcBe/WXP2zLnKvFWjalY
cTZVMEwlfwme4w23TJuuUzyVFBwla5TVYSDhsWzb+Nn3iZKIouy0ZFEdu25mlTt5
j5Z4HXaEoVzTMQ3EWnQwLt09hustnJ6KYyZp5vQ1uTJqCDKqd0XsVL2SJDLusqZg
ZUcAlLXg22Lk9R2xLEn44OZV/zf5EfRPtlZXjnWTG8NxcjTnTLqChZUsRiCDK2e7
TXdb8Nl2mV7cjGqxEb09Bf0Lx2Jp+yzABNBn8Ujm8j6oix3nMMIFo2ImaRj5FCiw
HB0iDfL4AaB0h7J2ch7ZgCHnRCPf9gJB5FNyvgxA2BpXapTRGK6+/YovHEdMlxgk
ZGk7UG1LnmUyxnH+js/jAgMBAAECggEBAK2h43XKdsPNVYNGPLfV+H1shtA4xWTF
B9lLpMcMktvsqBDoQb1bcaFbSDuoxtEHg3wlG+8Vf68QG4zjtl3Ioar8J+ZKED5e
fV/wE1U3I9cMlPIPLrmzOhYd+zLAmZKRKFehs5K+RY6cVD/BvNHz0oqyIjkU5X3E
0CvYhuk+ZNGevJ5xUqljVbW9M2FLWJlUGIkTlvuLQ9uAL0u2dEfC6PEVrUpdDFiT
D7lOcdOYBgeEaexa8Z3cKIO/9JmrsvFZHfDozo8YBvZdB/N/dmrmR1/jxlEJ59JW
F7h5pvJKbB2K3r/mA+D+yDBX+5jKyJs5VVnflcXs0B0CgYEA+8XqGXXuyO4Jt4xv
WiUXlHzl0l2qasPNT9GKWwBZG85R5eslOL2nnkLgZm/eb9v7rOixn1Z9ID1A0qQY
54i+KPXDgVQEn14i10FiX7x7v+ExXhOUhLVok8eHgRvOw/6hZoQD+a/JUbFJLwTg
V7RUo0s/zB3mR6Iu91XcnOOLy5UCgYEAzFpsoe6gV/pT4J21r3QzlGzgVv6JZhw6
ib0HeGUKm3ZTJF3KAl+7vIyZ2vfrKK4lIimTn/xfFJ/QH/K3H/B8Gtuj8j/vWIK1
2uWl3DwBFnjj8W07NE2XKtdbUERD4R4yvzUrFvNZhxZU1xQg22Lz3CWTMC7fWj+0
lFl9M/I3dJECgYEAxbTMC8o9cfsQhS5yfL4FplUu6svzvm3mV7s4QOWH6PbXGxyW
U7t

```
### 生成AES密钥
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import algorithms, Cipher, modes

def generate_aes_key():
    # 生成随机的盐值
    salt = b'\x00' * 16  # 16字节的盐值

    # 使用PBKDF2算法生成AES密钥
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,  # 32字节的AES密钥长度
        salt=salt,
        iterations=100000,  # 推荐的迭代次数
        backend=default_backend()
    )

    # 生成AES密钥
    aes_key = kdf.derive(b'')  # 使用空字节串作为密码

    return aes_key

# 生成AES密钥
aes_key = generate_aes_key()

# 打印生成的AES密钥
print("AES Key:")
print(aes_key.hex())

```
### 使用AES加密数据
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
import os

def encrypt_data(data, aes_key):
    # 生成随机的IV（Initialization Vector）
    iv = os.urandom(16)

    # 使用AES密钥和IV创建Cipher对象
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())

    # 创建加密器
    encryptor = cipher.encryptor()

    # 使用填充对数据进行加密
    padder = padding.PKCS7(algorithms.AES.block_size).padder()
    padded_data = padder.update(data.encode('utf-8')) + padder.finalize()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()

    # 返回加密后的数据和IV
    return ciphertext, iv

# 假设你已经有一个AES密钥
aes_key = bytes.fromhex("your_aes_key_in_hex_format")

# 要加密的数据
data_to_encrypt = "Hello, AES Encryption!"

# 加密数据
encrypted_data, iv = encrypt_data(data_to_encrypt, aes_key)

# 打印加密后的数据和IV
print("Encrypted Data:")
print(encrypted_data.hex())
print("IV:")
print(iv.hex())

```
### 使用AES解密数据
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding

def decrypt_data(encrypted_data, aes_key, iv):
    # 使用AES密钥和IV创建Cipher对象
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())

    # 创建解密器
    decryptor = cipher.decryptor()

    # 解密数据
    padded_data = decryptor.update(encrypted_data) + decryptor.finalize()

    # 移除填充
    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
    data = unpadder.update(padded_data) + unpadder.finalize()

    return data.decode('utf-8')

# 假设你已经有一个AES密钥
aes_key = bytes.fromhex("your_aes_key_in_hex_format")

# 假设你已经有一个IV
iv = bytes.fromhex("your_iv_in_hex_format")

# 加密后的数据（使用上面加密算法生成的）
encrypted_data = bytes.fromhex("encrypted_data_in_hex_format")

# 解密数据
decrypted_data = decrypt_data(encrypted_data, aes_key, iv)

# 打印解密后的数据
print("Decrypted Data:")
print(decrypted_data)

```