---
dg-publish: true
---
# 第1章绪论
Nothing.
## 1.1 数据结构的基本概念
### 1.1.1 基本概念和术语
### 1.1.2 数据结构三要素
### 1.1.3 本节试题精选
### 1.1.4 答案与解析

## 1.2 算法和算法评价
### 1.2.1 算法的基本概念
### 1.2.2 算法效率的度量
### 1.2.3 本节试题精选
### 1.2.4 答案与解析

# 第2章线性表
## 2.1 线性表的定义和基本操作
### 2.1.1 线性表的定义
### 2.1.2 线性表的基本操作
### 2.1.3 本节试题精选
### 2.1.4 答案与解析

## 2.2 线性表的顺序表示
### 2.2.1 顺序表的定义
### 2.2.2 顺序表上基本操作的实现
### 2.2.3 本节试题精选
### 2.2.4 答案与解析

## 2.3 线性表的链式表示
### 2.3.1 单链表的定义
```cpp
typedef struct LNode{
	Element data;
	struct LNode *next;
}LNode, *LinkList;
```
### 2.3.2 单链表上基本操作的实现
#### 头插法建立单链表
```cpp
LinkList List_HeadInsert(LinkList &L){
	LNode *s; int x;
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	scanf("%d",&x);
	while(x!=9999){
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		s->next=L->next;
		L->next=s;
		scanf("%d",&x);
	}
	return L;
}
```
#### 尾插法建立单链表
```cpp
LinkList List_TailInsert(LinkList &L){
	int x;
		L=(LinkList)malloc(sizeof(LNode));
		LNode *s, *r=L;
		scanf("%d", &x);
		while(x!=9999){
			s=(LNode*)malloc(sizeof(LNode));
			s->data=x;
			r->next=s;
			r=s;
			scanf("%d",&x);
		}
		r->next=NULL;
		return L;
}
```
#### 按序号查找结点
```cpp
LNode *GetElem(LinkList &L, int x) {
    if (x <= 0) return NULL;
    LNode *p = L;
    while (p != NULL && x--) {
        p = p->next;
    }
    return p;
}
```
#### 按值查找表结点
```cpp
LNode *LocateElem(LinkList &L, Elemtype e){
    if(L==NULL) return NULL;
    LNode *p=L->next;
    while(p!=NULL&&p->data!=e){
        p=p->next;
    }
    return p;
}
```
#### 插入结点
```cpp
void List_Insert(LinkList &L, int index, Elemtype e) {
    LNode *p = GetElem(L, index - 1);
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
}
```
#### 插入结点 (前插)//将\*s 结点插入到\*p 之前
```cpp
void List_preInsert(LNode *p, LNode *s){
    s->next=p->next;
    p->next=s;
    Elemtype temp=s->data;
    s->data=p->data;
    p->data=temp;
}
```
#### 删除结点
```cpp
void List_Delete(LinkList &L, int index) {
    LNode *p = GetElem(L, index - 1);
    LNode *q = p->next;
    if (q == NULL) return;
    p->next = q->next;
    free(q);
}
```
#### 删除下一个结点
```cpp
void List_nextDelete(LNode *p) {
    LNode *q = p->next;
    if (q == NULL) return;
    p->data = q->data;
    p->next = q->next;
    free(q);
}
```
#### 求表长
```cpp
int List_getLength(const LinkList &L) {
    LNode *p = L;
    int len = 0;
    while (p != NULL) {
        p = p->next;
        len++;
    }
    return len;
}
```
### 2.3.3 双链表
#### 插入操作
```cpp
void DList_Insert(DNode *p, DNode *s) {
    s->next = p->next;
    s->prior = p;
    s->next->prior = s;
    p->next = s;    //p->next总是放在最后修改(虽然不是必须)
}
```
#### 删除操作
```cpp
void DList_Delete(DNode *p) {
    DNode *q = p->next;
    p->next = q->next;
    q->next->prior = p;
    free(q);
}
```
### 2.3.4 循环链表
#### 循环单链表
判空条件: 头结点的指针域指向头结点时链表为空
#### 循环双链表
判空条件: 头结点的指针域 (next 和 prior)都指向头结点时链表为空
### 2.3.5 静态链表
```cpp
#define MAXSIZE 50
typedef int Elemtype;
typedef struct {
    Elemtype data;
    int next;
} SLinkList[MAXSIZE];
```
### 2.3.6 顺序表和链表的比较
### 2.3.7 本节试题精选
### 2.3.8 答案与解析
# 第3章栈、队列和数组
## 3.1 栈
### 3.1.1 栈的基本概念
### 3.1.2 栈的顺序存储结构
#### 顺序栈的实现
```cpp
#define MAXSIZE 50
typedef struct {
    Elemtype data[MAXSIZE];
    int top;
} SqStack;
```
#### 顺序栈的基本运算
top 指向的是栈顶元素, 当没有栈顶元素时 (即空栈), top=-1; 因此进栈时先+1, 再进栈. 出栈时先出栈再-1;
1. 初始化
```cpp
void InitStack(SqStack &S) {
    S.top = -1;
}
```
2. 判空
```cpp
bool Stack_isEmpty(SqStack &S) {
    return S.top == -1;
}
```
3. 进栈
```cpp
bool Push(SqStack &S, Elemtype e) {
    if (S.top == MAXSIZE - 1) return false;
    S.data[++S.top] = e;
    return true;
}
```
4. 出栈
```cpp
bool Pop(SqStack &S, Elemtype e) {
    if (S.top == -1) return false;
    e = S.data[S.top--];
    return true;
}
```
5. 读栈顶元素
```cpp
bool Top(SqStack &S, Elemtype e) {
    if (S.top == -1) return false;
    e = S.data[S.top];
    return true;
}
```
### 3.1.3 栈的链式存储结构
### 3.1.4 本节试题精选
### 3.1.5 答案与解析

## 3.2 队列
### 3.2.1 队列的基本概念
### 3.2.2 队列的顺序存储结构
#### 队列的顺序存储的实现
```cpp
#define MAXSIZE 50
typedef struct {
    Elemtype data[MAXSIZE];
    int front, rear;
} SqQueue;
```
#### 循环队列的操作
1. 初始化
```cpp
void InitQueue(SqQueue &Q) {
    Q.rear = Q.front = 0;
}
```
2. 判队空
```cpp
bool Queue_isEmpty(SqQueue &Q) {
    return Q.front == Q.rear;
}
```
3. 判队满
```cpp
bool Queue_isFull(SqQueue &Q) {
    return (Q.rear + 1) % MAXSIZE == Q.front;
}
```
4. 入队
```cpp
bool EnQueue(SqQueue &Q, Elemtype e) {
    if (Queue_isFull(Q)) return false;
    Q.data[Q.rear] = e;
    Q.rear = (Q.rear + 1) % MAXSIZE;
    return true;
}
```
5. 出队
```cpp
bool DeQueue(SqQueue &Q, Elemtype e) {
    if (Queue_isEmpty(Q)) return false;
    e = Q.data[Q.front];
    Q.front = (Q.front + 1) % MAXSIZE;
    return true;
}
```
### 3.2.3 队列的链式存储结构
#### 队列链式存储结构
```cpp
typedef struct LinkNode {
    Elemtype data;
    LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;
} *LinkQueue;
```
#### 链式队列的基本操作
1. 初始化
```cpp
void InitLinkQueue(LinkQueue &Q) {
    Q->front = Q->rear = (LinkNode *) malloc(sizeof(LinkNode));
    Q->front->next = NULL;
}
```
2. 判队空
```cpp
bool LinkQueue_isEmpty(LinkQueue &Q) {
    return Q->front == Q->rear;
}
```
3. 入队
```cpp
void EnLinkQueue(LinkQueue &Q, Elemtype e) {
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    s->data = e;
    s->next = NULL;
    Q->rear->next = s;
    Q->rear = s;
}
```
4. 出队
```cpp
bool DeLinkQueue(LinkQueue &Q, Elemtype e) {//Q->front是头结点，不随着入队出队移动。
    if (LinkQueue_isEmpty(Q)) return false;
    LinkNode *q = Q->front;
    e = q->data;
    Q->front->next = q->next;
    if (Q->rear == q) Q->rear = Q->front;
    free(q);
    return true;
}
```
### 3.2.4 双端队列
### 3.2.5 本节试题精选
### 3.2.6 答案与解析

## 3.3 栈和队列的应用
### 3.3.1 栈在括号匹配中的应用
#### 括号匹配
```cpp
bool BracketsCheck(char *str) {
    SqStack S;
    InitStack(S);
    int i = 0;
    Elemtype e;
    while (str[i] != '\0') {
        switch (str[i]) {
            case '(':
                Push(S, '(');
                break;
            case '[':
                Push(S, '[');
                break;
            case '{':
                Push(S, '{');
                break;
            case ')':
                Pop(S, e);
                if (e != '(') return false;
                break;
            case ']':
                Pop(S, e);
                if (e != ']') return false;
                break;
            case '}':
                Pop(S, e);
                if (e != '}') return false;
                break;
            default:
                break;
        }
        i++;
    }
    if (!Stack_isEmpty(S)) return false;
    return true;
}
```
### 3.3.2 栈在表达式求值中的应用
#### 手算算法
1. 按照运算符优先级对所有运算单位加括号
2. 前缀：把运算符移动到对应括号前面
	后缀：把运算符移动到对应括号后面
3. 把括号去掉
### 3.3.3 栈在递归中的应用
### 3.3.4 队列在层次遍历中的应用
### 3.3.5 队列在计算机系统中的应用
### 3.3.6 本节试题精选
### 3.3.7 答案与解析

## 3.4 数组和特殊矩阵
### 3.4.1 数组的定义
### 3.4.2 数组的存储结构
### 3.4.3 特殊矩阵的压缩存储
### 3.4.4 稀疏矩阵
### 3.4.5 本节试题精选
### 3.4.6 答案与解析

# 第4章串
## 4.1 串的定义和实现
### 4.1.1 串的定义
### 4.1.2 串的存储结构
#### 定长顺序存储表示
```cpp
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN];
    int length;
} SString;
```
#### 堆分配存储表示
```cpp
typedef struct {
    char *ch;
    int length;
} HString;
```
### 4.1.3 串的基本操作
#### 最小操作子集
- 串赋值
- 串比较
- 求串长
- 串联接
- 求子串
## 4.2 串的模式匹配
### 4.2.1 简单的模式匹配算法
```cpp
int Locate(SString &S, SString &T) {
    int i = 1, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i] == T.ch[j]) {
            i++;
            j++;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if(j>T.length) return i-T.length;
    return 0;
}
```
### 4.2.2 串的模式匹配算法——KMP算法
### 4.2.3 KMP算法的进一步优化
### 4.2.4 本节试题精选
### 4.2.5 答案与解析

# 第5章树与二叉树
## 5.1 树的基本概念
### 5.1.1 树的定义
### 5.1.2 基本术语
### 5.1.3 树的性质
### 5.1.4 本节试题精选
### 5.1.5 答案与解析

## 5.2 二叉树的概念
### 5.2.1 二叉树的定义及其主要特性
### 5.2.2 二叉树的存储结构
#### 顺序存储结构
数组下标从 1 开始，若数组下标从 0 开始则无法根据性质找到其孩子结点。
#### 链式存储结构
```cpp

```
### 5.2.3 本节试题精选
### 5.2.4 答案与解析

## 5.3 二叉树的遍历和线索二叉树
### 5.3.1 二叉树的遍历
==可快速写出三种遍历序列==
![[数据结构_20230824122245.png]]
#### 先序遍历
图的深度优先搜索算法==DFS==退化为树的先序遍历算法
```cpp
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}
}
```
#### 中序遍历
```cpp
void InOrder(BiTree T){
	if(T!=NULL){
		InOrder(T->lchild);
		visit(T);
		InOrder(T->rchild);
	}
}
```

#### 后序遍历
```cpp
void PostOrder(BiTree T){
	if(T!=NULL){
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```
#### 中序遍历非递归算法
```cpp
void InOrder2(BiTree T){
	InitStack(S);
	BiTree p=T;
	while(p||!isEmpty(S)){//情况1：p不空； 情况2：p空且栈不空；两个情况互补。
		if(p){//情况1：p不空
			Push(S,p);
			p=p->lchild;
		}else{//情况2：p空且栈不空
			Pop(S,p);
			visit(p);
			p=p->rchild;
		}
	}
}
```
#### 先序遍历非递归算法
和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面
```cpp
void PreOrder2(BiTree T){
	InitStack(S);
	BiTree p=T;
	while(p||!isEmpty(S)){
		if(p){
			visit(P);//在刚访问到时就读取,先序.
			Push(S,p);
			p=p->lchild;
		}else{
			Pop(S,p);
			p=p->rchild;
		}
	}
}
```
#### 后序遍历非递归算法
==重要性质==
访问一个结点p时,栈中结点恰好是p的所有祖先,从栈底到栈顶再加上p刚好构成了从根节点到p的一条路径.可以利用这个性质求==根到某结点的路径==,求==两个结点的最近公共祖先==.
```C++

```
#### 层序遍历
图的广度优先搜索算法==BFS==退化成树的层序遍历算法
```cpp
void LevelOrder(BiTree T){
	InitQuere(Q);
	BiTree p;
	Enquere(Q,T);
	while(!isEmpty(Q)){
		DeQueue(Q,p);
		visit(p);
		if(p->lchild!=NULL)
			EnQueue(Q,p->lchild);
		if(P->rchild!=NULL)
			EnQueue(Q,p->rchild);
	}
}
```
#### 由遍历序列构造二叉树
中序&&(先序||后序||层序)均可唯一确定一棵二叉树, 前序+后序可以确定祖先关系.
1. ==先序序列第一个==结点是根节点;==后序序列最后一个==结点是根节点;==层序序列第一个==结点是根节点.
2. 中序序列根节点左边是左子树,右边是右子树.
3. 递归调用.
### 5.3.2 线索二叉树
> 先序线索不方便找前驱
> 后序线索不方便找后继

> 先序线索找后继:
> 1. 左孩子
> 2. 右孩子
> 3. 右链域

> 三种遍历访问左右子树的先后顺序不变(只是访问根的顺序不同), 因此叶结点的访问顺序完全相同

> 前序和中序的关系相当于以前序作为入栈次序, 以中序作为出栈次序. 可用CataLan数解决排列组合问题.
> $$\frac{1}{n+1} C_{2n}^{n} $$
```cpp
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild, *rchild;
	int ltag,rtag;
}ThreadNode,*ThreadTree;
```
#### 中序线索二叉树的构造
二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。
以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p.
```cpp
void InThread(ThreadTree &p, ThreadTree &pre){
	if(p!=NULL){
		InThread(p->lchild,pre);//递归,线索化左子树
		if(p->lchild==NULL){
			p->lchild=pre;
			p->ltag=1;
		}
		if(pre!=NULL&&pre->rchild==NULL){
			pre->rchild=p;
			pre->rtag=l;
		}
		pre=p;
		InThread(p->rchild,pre);//递归,线索化右子树
	}
}

void CreateInThread(ThreadTree T){
	ThreadTree pre=NULL;
	if(T!=NULL){
		InThread(T,pre);
		pre->rchild=NULL;
		Pre->rtag=1;
	}
} 
```
#### 中序线索二叉树的遍历
1. 求中序线索二叉树中中序序列下的第一个结点:
```cpp
ThreadNode *Firstnode(ThreadNode *p){
	while(p->ltag==0) p=p->lchild;//最左下结点(不一定是叶结点)
	return p;
}
```
2. 求中序线索二叉树下结点p在中序序列下的后继:
```cpp
ThreadNode *Nextnode(ThreadNode *p){
	if(p->rtag==0) return Firstnode(p->rchild);//右子树最左下的结点
	else return p->rchild;
}
```
3.不含头结点的中序线索二叉树的中序遍历算法:
```cpp
void Inorder(ThreadNode *T){
	for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p))
		visit(p);
}
```
#### 中序线索二叉树的反向遍历
与正向遍历刚好相反, 最后一个结点是最右下的结点(不一定是叶节点). 前驱是左子树最右下的结点(ltag=0)
1. 求中序线索二叉树中中序序列下的最后一个结点:
```cpp
ThreadNode *Lastnode(ThreadNode *p){
	while(p->rtag==0) p=p->rchild;//最右下结点(不一定是叶结点)
	return p;
}
```
2. 求中序线索二叉树下结点p在中序序列下的前驱:
```cpp
ThreadNode *Previousnode(ThreadNode *p){
	if(p->ltag==0) return Firstnode(p->lchild);//左子树最右下的结点
	else return p->lchild;
}
```
3.不含头结点的中序线索二叉树的中序遍历算法:
```cpp
void ReverseInorder(ThreadNode *T){
	for(ThreadNode *p=Lastnode(T);p!=NULL;p=Previousnode(p))
		visit(p);
}
```
### 5.3.3 本节试题精选
### 5.3.4 答案与解析

## 5.4 树、森林
### 5.4.1 树的存储结构
### 5.4.2 树、森林与二叉树的转换
### 5.4.3 树和森林的遍历
### 5.4.4 本节试题精选
### 5.4.5 答案与解析

## 5.5 树与二叉树的应用
### 5.5.1 哈夫曼树和哈夫曼编码
### 5.5.2 并查集
```cpp
#define SIZE 100

int UFSets[SIZE];

void Init(int S[]) {
    for (int i = 0; i < SIZE; ++i) {
        S[i] = -1;
    }
}

int find(int S[], int x) {
    while (S[x] >= 0) {
        x = S[x];
    }
    return x;
}

void Union(int S[], int root1, int root2) {
    if (root1 == root2) return;
    S[root2] == root1;
}
```
### 5.5.3 本节试题精选
### 5.5.4 答案与解析

# 第6章图
## 6.1 图的基本概念
### 6.1.1 图的定义
### 6.1.2 本节试题精选
### 6.1.3 答案与解析
## 6.2 图的存储及基本操作
### 6.2.1 邻接矩阵法
### 6.2.2 邻接表法
### 6.2.3 十字链表
==有向图==
沿着==绿色==路径找到顶点所有==出边==
沿着==橙色==路径找到顶点所有==入边==

![[数据结构_20230824115204.png]]
### 6.2.4 邻接多重表
==无向图==
![[数据结构_20230824115552.png]]
### 6.2.5 图的基本操作
### 6.2.6 本节试题精选
### 6.2.7 答案与解析
## 6.3 图的遍历
> BFS　－＞　树的层序遍历
> DFS　－＞　树的先序遍历
### 6.3.1 广度优先搜索
```cpp
bool visited[MAX_VERTEX_NUM];
void BFSTraverse(Graph G){
	for(i=0;i<G.vexnum;++i)
		visited[i]=FALSE;
	InitQueue(Q);
	for(i=0;i<G.vexnum;++i)
		if(!visited[i])
			BFS(G,i);					  
}

void BFS(Graph G,int v){
	visit(v);
	visited[v]=TRUE;
	Enqueue(Q,v);
	while(!isEmpty(Q)){
		DeQueue(Q,v);
		for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
			if(!visited[w]){
				visit(w);
				visited[w]=TRUE;
				EnQueue(Q,w);
			}
	}					
}
```
#### BFS算法的性能分析
BFS算法需要借助一个辅助队列Q，n个顶点均需入队一次，在最坏的情况下，==空间复杂度==为为$O(\left | V \right | )$
采用邻接表存储方式时,每个顶点均需搜索一次（或入队一次），故时间复杂度为$O(\left | V \right | )$，在搜索任意一个顶点的邻接点时，每条边至少访问一次，故时间复杂度为$O(\left | E \right | )$,算法==总的时间复杂度==为$O(\left | V \right | + \left | E \right | )$
#### BFS算法求解单源最短路径问题
若图G = (V, E)为非带权图，定义从顶点u到顶点v的最短路径d(u, v)为从u到v的任何路径中最少的边数；若从u到v没有通路，则d(u,v)=∞。
``` cpp
void BFS_MIN_Distance(Graph G,int u){
	for(i=0;i<G.vexnum;++i)
		d[i]=∞;
	visited[u]=TRUE;
	d[u]=0;
	EnQueue(Q,u);
	while(!isEmpty(Q)){
		DeQueue(Q,u);
		for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w))
			if(!visited[w]){
				visited[w]=TRUE;
				d[w]=d[u]+1;
				EnQueue(Q,w);
			}
	}
}
```
#### 广度优先生成树
同一个图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。
### 6.3.2 深度优先搜索
``` cpp
bool visited[MAX_VERTEX_NUM];
void DFSTraverse(Graph G){
	for(v=0;v<G.vexnum;v++)
		visited[v]=FALSE;
	for(v=0;v<G.vexnum;v++)
		if(!visited[v])
			DFS(G,v);
}
void DFS(Graph G, int v){
	visit(v);
	visited[v]=TRUE;
	for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
		if(!visited[w])
			DFS(G,w);
}
```
#### DFS算法的性能分析
DFS算法是一个递归算法，需要借助一个递归工作栈，故其==空间复杂度==为$O(\left | V \right | )$
遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所用的存储结 构。以==邻接矩阵==表示时,查找每个顶点的邻接点所需的时间为$O(\left | V \right | )$，故总的时间复杂度为$O(\left | V \right | ^{2} )$。 以邻接表表示时,查找所有顶点的邻接点所需的时间为$O(\left | E \right | )$，访问顶点所需的时间为$O(\left | V \right | )$，此时，总的时间复杂度为$O(\left | V \right | + \left | E \right | )$。
#### 深度优先的生成树和生成森林
与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的， 即对==连通图调用DFS才能产生深度优先生成树==，否则产生的将是==深度优先生成森林==。与BFS类似，基于==邻接表==存储的深度优先生成树是不唯一的。
### 6.3.3 图的遍历与图的连通性
对于无向图来说，若无向图是连通的，则从任意一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所 在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶，点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。
对于无向图，BFSTraverse()或DFSTraverse()调用BFS (G, i)或DFS (G,i) 的次数等于该图的==连通分量数==；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，一次调用BFS（Ｇ，ｉ）或DFS（Ｇ，ｉ）无法访问到该连通分量所有顶点。
### 6.3.4 本节试题精选
### 6.3.5 答案与解析
## 6.4 图的应用
### 6.4.1 最小生成树
#### Prim算法

#### Kruskal算法

### 6.4.2 最短路径
### 6.4.3 有向无环图描述表达式
### 6.4.4 拓扑排序
### 6.4.5 关键路径
### 6.4.6 本节试题精选
### 6.4.7 答案与解析

# 第7章查找
## 7.1 查找的基本概念
## 7.2 顺序查找和折半查找
### 7.2.1 顺序查找
```cpp
typedef int Elemtype;

typedef struct {
    Elemtype *elem;
    int len;
} SSTable;

int SeqSearch(SSTable ST, Elemtype key) {
    ST.elem[0] = key;
    int i;
    for (i = ST.len; ST.elem[i] != key; --i);
    return i;
}
```
### 7.2.2 折半查找
```cpp
int BinarySearch(SSTable ST, Elemtype key) {
    int low = 0, high = ST.len - 1, mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (ST.elem[mid] == key) return mid;
        if (ST.elem[mid] < key) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```
### 7.2.3 分块查找
//正确性有待验证
```cpp
typedef struct {
    Elemtype max;
    int index;
} Block;

typedef struct {
    Block *indexTable;
    int indexLength;
    Elemtype *elem;
    int elemLength;
} SBTable;

//待验证正确性
int BlkSearch(SBTable SB, Elemtype key) {
    int low = 0, high = SB.indexLength - 1, mid;
    int index1 = -1, index2 = -1;
    while (high - low > 1) {
        mid = (low + high) / 2;
        if (SB.indexTable[mid].max == key) {
            index1 = SB.indexTable[mid].index;
            if (mid != SB.indexLength - 1) index2 = SB.indexTable[mid + 1].index;
            break;
        }
        if (SB.indexTable[mid].max < key) low = mid;
        else high = mid;
    }
    if (index1 == -1) {
        index1 = SB.indexTable[high].index;
        if (high != SB.indexLength - 1) index2 = SB.indexTable[high + 1].index;
    }
    if (index2 == -1) index2 = SB.elemLength - 1;
    int i;
    for (i = index1; i <= index2 && SB.elem[i] != key; ++i);
    if (i > index2) return -1;
    return i;
}
```
### 7.2.4 本节试题精选
### 7.2.5 答案与解析
## 7.3 树型查找
### 7.3.1 二叉排序树(BST)
#### 二叉排序树非递归查找
```cpp
BiTNode *BST_Search(BiTree &T, ElemType e) {
    while (T && T->data != e) {
        if (e < T->data) T = T->lchild;
        else T = T->rchild;
    }
    return T;
}
```
#### 二叉排序树插入
```cpp
bool BST_Insert(BiTree &T, ElemType key) {
    if (T == NULL) {//即插入点，可以是原先不存在的根节点也可以是待插入的叶结点
        T = (BiTree) malloc(sizeof(BiTNode));//因为T是引用类型，所以更改会直接发生在父节点的指针域上，不需要保存父节点的信息。
        T->data = key;
        T->lchild = T->rchild = NULL;
        return true;
    } else if (T->data == key) {
        return false;
    } else if (key < T->data) {
        BST_Insert(T->lchild, key);
    } else {
        BST_Insert(T->rchild, key);
    }
}
```
#### 二叉排序树构造
```cpp
void BST_Create(BiTree &T, ElemType data[], int n) {//T=NULL为空树，只有类型声明，没用申请空间。
    for (int i = 0; i < n; ++i) {
        BST_Insert(T, data[i]);
    }
}
```

### 7.3.2 平衡二叉树
### 7.3.3 红黑树
### 7.3.4 本节试题精选
### 7.3.5 答案与解析

## 7.4 B树和B+树
### 7.4.1 B树及其基本操作
### 7.4.2 B+树的基本概念
### 7.4.3 本节试题精选
### 7.4.4 答案与解析

## 7.5 散列表

### 7.5.1 散列表的基本概念
### 7.5.2 散列函数的构造方法
### 7.5.3 处理冲突的方法
### 7.5.4 散列查找及性能分析
### 7.5.5 本节试题精选
### 7.5.6 答案与解析

# 第8章排序

## 8.1 排序的基本概念
### 8.1.1 排序的定义
### 8.1.2 本节试题精选
### 8.1.3 答案与解析

## 8.2 插入排序

### 8.2.1 直接插入排序
```cpp
void Insert_Sort(Elemtype data[], int n) {
    int i, j;
    for (i = 2; i <= n; ++i) {
        data[0] = data[i];
        for (j = i - 1; data[0] < data[j]; --j) {//data[i]可能被修改，使用data[0]替代
            data[j + 1] = data[j];
        }
        data[j + 1] = data[0];
    }
}
```
### 8.2.2 折半插入排序
```cpp
void HalfInsert_Sort(Elemtype data[], int n) {
    int i, j;
    int low, high, mid;
    for (i = 2; i <= n; i++) {
        data[0] = data[i];
        low = 1;
        high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
//            if (data[0] == data[mid]) break;//注释掉。即认为元素值不会重复。
//            事实上元素值重复了也没关系，因为如果让元素值相等时，把data[mid]看作比data[0]小，
//            则按小于的情况时的逻辑把data[0]插入到mid位置之后的其中一个位置。则进行low=mid+1的操作。
            if (data[0] < data[mid]) high = mid - 1;
            else low = mid + 1;
        }
        for (j = i - 1; j >= high + 1; --j) {
            data[j + 1] = data[j];
        }
        data[j + 1] = data[0];
    }
}
```
### 8.2.3 希尔排序
```cpp
//减小增量的直接插入排序，和直接插入排序比较学习。
void ShellSort(Elemtype data[], int n) {
    int i, j, dk;
    for (dk = n / 2; dk >= 1; dk /= 2) {
        for (i = dk + 1; i <= n; i++) {
            data[0] = data[i];
            for (j = i - dk; j > 0 && data[0] < data[j]; j -= dk)//j>0避免数组发生越界错误，增强鲁棒性。
                data[j + dk] = data[j];
            data[j + dk] = data[0];
        }
    }
}
```
### 8.2.4 本节试题精选
### 8.2.5 答案与解析

## 8.3 交换排序

### 8.3.1 冒泡排序
```cpp
void BubbleSort(Elemtype data[], int n) {
    int i, j, t;
    //当i=n-1时，第二个for循环进不去，可以剪枝剪掉。
    // 而且当进行n-1次冒泡后，n-1个元素都已经确认在前n-1个位置上了，第n个元素最终位置一定是在第n个位置上。
    //i=0表示此次for循环结束后index=0的位置上放的是最终的元素。
    // 因此在循环结束前会发生data[i]与data[i+1]互换的情况。即j=i+1，data[j]与data[j-1]互换
    for (i = 0; i < n - 1; i++) {
        bool flag = false;
        for (j = n - 1; j > i; j--) {
            if (data[j] < data[j - 1]) {
                t = data[j];
                data[j] = data[j - 1];
                data[j - 1] = t;
                flag = true;
            }
        }
        if (!flag) return;
    }
}
```
### 8.3.2 快速排序
```cpp
void QuickSort(Elemtype data[], int low, int high) {
    int pivotpos = Partition(data, low, high);
    QuickSort(data, low, pivotpos - 1);
    QuickSort(data, pivotpos + 1, high);
}

int Partition(Elemtype data[], int low, int high) {
    Elemtype pivot = data[low];
    while (low < high) {//不断地把小于枢轴的换到左边，大于枢轴的换到右边。直到low=high时把枢轴填入。
        while (low < high && data[high] > pivot) high--;
        data[low] = data[high];
        while (low < high && data[low] < pivot) low++;
        data[high] = data[low];
    }
    data[low] = pivot;//low==high
    return low;//low==high
}
```
### 8.3.3 本节试题精选
### 8.3.4 答案与解析

## 8.4 选择排序

### 8.4.1 简单选择排序
```cpp
void SelectSort(Elemtype data[], int n) {
    int i, j, index, temp;
    for (i = 0; i < n - 1; i++) {
        index = i;
        for (i = i + 1; j < n; j++) {
            if (data[j] < data[index]) {
                index = j;
            }
        }
        temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }
}
```
### 8.4.2 堆排序
```cpp
void BuildMaxHeap(Elemtype *data, int len) {
    int i;
    for (i = len / 2; i > 0; i--) {
        HeadAdjust(data, i, len);
    }
}

void HeadAdjust(Elemtype *data, int root, int len) {//非递归
    data[0] = data[root];
    int i;
    for (i = root * 2; i <= len; i *= 2) {
        if (i < len && data[i + 1] > data[i]) i++;
        if (data[i] < data[0]) break;
        else {
            data[root] = data[i];
            root = i;
        }
    }
    data[root] = data[0];
}

void MaxHeapSort(Elemtype *data, int len) {//大根堆经历的堆排序是升序序列
    BuildMaxHeap(data, len);
    int i;
    for (i = len; i > 1; i--) {
        Swap(data[i], data[1]);
        HeadAdjust(data, 1, i - 1);//第i个元素已有序，即位于最终位置上
    }
}
```
### 8.4.3 本节试题精选
### 8.4.4 答案与解析

## 8.5 归并排序和基数排序

### 8.5.1 归并排序
```cpp
Elemtype *B = (Elemtype *) malloc((n + 1) * sizeof(Elemtype));

void Merge(Elemtype A[], int low, int mid, int high) {//归并
    int i, j, k;
    for (k = low; k <= high; k++) B[k] = A[k];
    for (i = low, j = mid + 1, k = low; i <= mid && j <= high; k++) {//这一分段从index=low开始，k是用于遍历填充这一分段的遍历，所以和左段的i起始位置相同
        if (B[i] < B[j]) A[k] = B[i++];
        else A[k] = B[j++];
    }
    while (i <= mid) A[k++] = B[i++];//只有一个while会执行
    while (j <= high) A[k++] = B[j++];
}

void MergeSort(Elemtype A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);//对左侧进行归并排序
        MergeSort(A, mid + 1, high);//对右侧进行归并排序
        Merge(A, low, mid, high);//左右两侧都已完成排序，进行归并。
    }
}
```
### 8.5.2 基数排序
### 8.5.3 本节试题精选
### 8.5.4 答案与解析

## 8.6 各种内部排序算法的比较及应用

### 8.6.1 内部排序算法的比较
### 8.6.2 内部排序算法的应用
### 8.6.3 本节试题精选
### 8.6.4 答案与解析

## 8.7 外部排序

### 8.7.1 外部排序的基本概念
### 8.7.2 外部排序的方法
### 8.7.3 多路平衡归并与败者树
### 8.7.4 置换-选择排序(生成初始归并段)
### 8.7.5 最佳归并树
### 8.7.6 本节试题精选
### 8.7.7 答案与解析
