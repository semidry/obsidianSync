---
dg-publish: true
---
[LCR 124. 推理二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/description/)
本题与主站 105 题重复：[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)
#分治 #树 
> [!info] 题目
> 某二叉树的先序遍历结果记录于整数数组 `preorder`，它的中序遍历结果记录于整数数组 `inorder`。请根据 `preorder` 和 `inorder` 的提示构造出这棵二叉树并返回其根节点。
注意：`preorder` 和 `inorder` 中均不含重复数字。

> [!cite] 示例 1
> ![[Pasted image 20240124153014.png]]
> **输入:** preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
**输出:** [3,9,20,null,null,15,7]

> [!cite] 示例 2
> **输入:** preorder = [-1], inorder = [-1]
**输出:** [-1]

> [!help] 提示
> - `1 <= preorder.length <= 3000`
> - `inorder.length == preorder.length`
> - `-3000 <= preorder[i], inorder[i] <= 3000`
> - `inorder` 均出现在 `preorder`- `preorder` 保证 为二叉树的前序遍历序列
> - `inorder` 保证 为二叉树的中序遍历序列
### 方法一
> [!example] 

**解题思路**：
前序遍历性质： 节点按照 `[ 根节点 | 左子树 | 右子树 ]` 排序。
中序遍历性质： 节点按照 `[ 左子树 | 根节点 | 右子树 ]` 排序。

> 以题目示例为例：
> - 前序遍历划分 `[ 3 | 9 | 20 15 7 ]`
> - 中序遍历划分 `[ 9 | 3 | 15 20 7 ]`
根据以上性质，可得出以下推论：
1. 前序遍历的首元素 为 树的根节点 node 的值。
2. 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 `[ 左子树 | 根节点 | 右子树 ]` 。
3. 根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 `[ 根节点 | 左子树 | 右子树 ] `。
![[Pasted image 20240124153519.png]]

通过以上三步，可确定 三个节点 ：1.树的根节点、2.左子树根节点、3.右子树根节点。

根据「分治算法」思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。

**分治解析**：
递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；

终止条件： 当 left > right ，代表已经越过叶节点，此时返回 null ；

递推工作：

1. 建立根节点 node ： 节点值为 `preorder[root]` ；
2. 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
> 为了提升效率，本文使用哈希表 hmap 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1) ；
3. 构建左右子树： 开启左右子树递归；

| | 根节点索引 | 中序遍历左边界 | 中序遍历右边界 | 
| ---- | ---- | ---- | ---- |
| 左子树 | $root + 1$ | $left$ | $i - 1$ |
| 右子树 | $i - left + root + 1$ | $i + 1$ | $right$ |
> TIPS： i - left + root + 1含义为 根节点索引 + 左子树长度 + 1

返回值： 回溯返回 node ，作为上一层递归中根节点的左 / 右子节点；
> [!success] 代码：
```cpp
class Solution {
public:
    TreeNode* deduceTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        for(int i = 0; i < inorder.size(); i++)
            hmap[inorder[i]] = i;
        return recur(0, 0, inorder.size() - 1);
    }
private:
    vector<int> preorder;
    unordered_map<int, int> hmap;
    TreeNode* recur(int root, int left, int right) { 
        if(left > right) return nullptr;                        // 递归终止
        TreeNode* node = new TreeNode(preorder[root]);          // 建立根节点
        int i = hmap[preorder[root]];                           // 划分根节点、左子树、右子树
        node->left = recur(root + 1, left, i - 1);              // 开启左子树递归
        node->right = recur(root + i - left + 1, i + 1, right); // 开启右子树递归
        return node;                                            // 回溯返回根节点
    }
};
```
> [!attention] 复杂度
**时间复杂度** $O(N)$ ： 其中 N 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 $O(N)$ 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 $O(1)$ ，因此使用 $O(N)$ 时间。
**空间复杂度** $O(N)$ ： HashMap 使用 $O(N)$ 额外空间；最差情况下（输入二叉树为链表时），递归深度达到 N ，占用 $O(N)$ 的栈帧空间；因此总共使用 $O(N)$ 空间。

> [!success] 另一种代码
```cpp
class Solution {
public:
    TreeNode* deduceTree(vector<int>& preorder, vector<int> inorder) {
        if (inorder.empty()) return nullptr;
        int rootVal = preorder.front();
        preorder.erase(preorder.begin());
        auto rootIndex = find(inorder.begin(), inorder.end(), rootVal) - inorder.begin();
        TreeNode* root = new TreeNode(rootVal);
        root->left = deduceTree(preorder, vector<int>(inorder.begin(), inorder.begin() + rootIndex));
        root->right = deduceTree(preorder, vector<int>(inorder.begin() + rootIndex + 1, inorder.end()));
        return root;
    }
};
```
