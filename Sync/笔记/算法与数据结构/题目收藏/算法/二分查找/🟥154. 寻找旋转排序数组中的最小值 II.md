---
dg-publish: true
---
[154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/)
用的是[LCR 128. 库存管理 I - 力扣（LeetCode）](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/102826/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/)的解析
#二分 
这道题与 [[🟧153. 寻找旋转排序数组中的最小值]] 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？
> [!info] 题目
> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：
> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
> - 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
你必须尽可能减少整个过程的操作步骤。

> [!cite] 示例 1
> **输入：**nums = [1,3,5]
**输出：**1

> [!cite] 示例 2
> **输入：**nums = [2,2,2,0,1]
**输出：**0

> [!help] 提示
> - `n == nums.length`
> - `1 <= n <= 5000`
> - `-5000 <= nums[i] <= 5000`
> - `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转
### 方法一
> [!example] 

如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 `stock[x]` ，称 x 为 旋转点 。

下图中的 numbers 对应本题的 stock 。
![[Pasted image 20240123164059.png]]
排序数组的查找问题首先考虑使用 二分法 解决，其可将 遍历法 的 线性级别 时间复杂度降低至 对数级别 。

算法流程：
1. 初始化： 声明 i, j 双指针分别指向 stock 数组左右两端；
2. 循环二分： 设 m = (i + j) / 2 为每次二分的中点（ "/" 代表向下取整除法，因此恒有 $i \leq m < j$），可分为以下三种情况：
	1. 当 `stock[m]>stock[j]` 时： m 一定在 左排序数组 中，即旋转点 x 一定在 `[m+1,j] `闭区间内，因此执行 i=m+1；
	2. 当 `stock[m]<stock[j]` 时： m 一定在 右排序数组 中，即旋转点 x 一定在`[i,m]`闭区间内，因此执行 j=m；
	3. 当 `stock[m]=stock[j]` 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 `[i,m] `还是 `[m+1,j] `区间中。解决方案： 执行 j=j−1 缩小判断范围。
		![[Pasted image 20240123164459.png]]
3. 返回值： 当 i=j 时跳出二分循环，并返回 旋转点的值 stock[i] 即可。

补充思考： 为什么本题二分法不用 `stock[m]` 和 `stock[i]` 作比较？

二分目的是判断 m 在哪个排序数组中，从而缩小区间。而在 `stock[m]>stock[i]`情况下，无法判断 m 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：

> 对于以下两示例，当 i=0,j=4,m=2 时，有 `stock[m] > stock[i]` ，而结果不同。
> `[1,2,3,4,5]` 旋转点 x=0 ： m 在右排序数组（此示例只有右排序数组）；
> `[3,4,5,1,2]` 旋转点 x=3 ： m 在左排序数组。

> [!success] 代码：
```cpp
class Solution {
public:
    int stockManagement(vector<int>& stock) {
        int i = 0, j = stock.size() - 1;
        while (i < j) {
            int m = (i + j) / 2;
            if (stock[m] > stock[j]) i = m + 1;
            else if (stock[m] < stock[j]) j = m;
            else j--;
        }
        return stock[i];
    }
};

```
实际上，当出现 `stock[m]=stock[j]` 时，一定有区间 `[i,m]` 内所有元素相等 或 区间 `[m,j]`内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代。
```cpp
class Solution {
public:
    int stockManagement(vector<int>& stock) {
        int i = 0, j = stock.size() - 1;
        while (i < j) {
            int m = (i + j) / 2;
            if (stock[m] > stock[j]) i = m + 1;
            else if (stock[m] < stock[j]) j = m;
            else {
                int x = i;
                for(int k = i + 1; k < j; k++) {
                    if(stock[k] < stock[x]) x = k;
                }
                return stock[x];
            }
        }
        return stock[i];
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(logN)$
> - **空间复杂度**：$O(1)$

