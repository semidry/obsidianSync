---
dg-publish: true
---
[LCR 172. 统计目标成绩的出现次数 - 力扣（LeetCode）](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/description/)
本题与主站 34 题相同：[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
#二分 
> [!info] 题目
某班级考试成绩按非严格递增顺序记录于整数数组 `scores`，请返回目标成绩 `target` 的出现次数。

> [!cite] 示例 1
> **输入:** scores = [2, 2, 3, 4, 4, 4, 5, 6, 6, 8], target = 4
**输出:** 3

> [!cite] 示例 2
> **输入:** scores = [1, 2, 3, 5, 7, 9], target = 6
**输出:** 0

> [!help] 提示
> 
### 方法一
> [!example] 

解题思路：
> 排序数组中的搜索问题，首先想到 二分查找 解决。

排序数组 scores 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left 和 right ，分别对应窗口左边 / 右边的首个元素。

本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right−left−1 。

> 下图中的 nums 对应本题的 scores 。

![[Pasted image 20240123150441.png]]
效率优化：
> 以下优化基于：查找完右边界 right=iright = iright=i 后，则 `scores[j]` 指向最右边的 targettargettarget （若存在）。
- 查找完右边界后，可用 `scores[j]=target` 判断数组中是否包含 target ，若不包含则直接提前返回 0 ，无需后续查找左边界。
- 查找完右边界后，左边界 left 一定在闭区间 `[0,j]` 中，因此直接从此区间开始二分查找即可。

## 代码：

可将 `scores[m]=target` 情况合并至其他两种情况中。

> [!error] 不要使用这个代码
```cpp
class Solution {
public:
    int countTarget(vector<int>& scores, int target) {
        // 搜索右边界 right
        int i = 0, j = scores.size() - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(scores[m] <= target) i = m + 1;
            else j = m - 1;
        }
        int right = i;
        // 若数组中无 target ，则提前返回
        if(j >= 0 && scores[j] != target) return 0;
        // 搜索左边界 right
        i = 0; j = scores.size() - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(scores[m] < target) i = m + 1;
            else j = m - 1;
        }
        int left = j;
        return right - left - 1;
    }
};
```
以上代码显得比较臃肿（两轮二分查找代码冗余）。为简化代码，可将二分查找右边界 right 的代码 封装至函数 helper() 。
如下图所示，由于数组 scores 中元素都为整数，因此可以分别二分查找 target 和 target−1 的右边界，将两结果相减并返回即可。

![[Pasted image 20240123150453.png]]

本质上看，helper() 函数旨在查找数字 tar 在数组 scores 中的 插入点 ，且若数组中存在值相同的元素，则插入到这些元素的右边。

> [!success] 代码：
```cpp
class Solution {
public:
    int countTarget(vector<int>& scores, int target) {
        return helper(scores, target) - helper(scores, target - 1);
    }
private:
    int helper(vector<int>& scores, int tar) {
        int i = 0, j = scores.size() - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(scores[m] <= tar) i = m + 1;
            else j = m - 1;
        }
        return i;
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(logN)$
> - **空间复杂度**：$O(1)$

