[119. 杨辉三角 II - 力扣（LeetCode）](https://leetcode.cn/problems/pascals-triangle-ii/solutions/601082/yang-hui-san-jiao-ii-by-leetcode-solutio-shuk/)
### 问题描述
给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

**示例 1:**

> **输入:** rowIndex = 3
> **输出:** `[1,3,3,1]`

**示例 2:**

> **输入:** rowIndex = 0
> **输出:** `[1]`

**示例 3:**

> **输入:** rowIndex = 1
> **输出:** `[1,1]`
### 解答
#### 方法一：递推
#数学
![[Pasted image 20240113203953.png]]
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>> C(rowIndex + 1);
        for (int i = 0; i <= rowIndex; ++i) {
            C[i].resize(i + 1);
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; ++j) {
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
            }
        }
        return C[rowIndex];
    }
};
```
**优化**

注意到对第 i+1 行的计算仅用到了第 i 行的数据，因此可以使用**滚动数组**的思想优化空间复杂度。
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> pre, cur;
        for (int i = 0; i <= rowIndex; ++i) {
            cur.resize(i + 1);
            cur[0] = cur[i] = 1;
            for (int j = 1; j < i; ++j) {
                cur[j] = pre[j - 1] + pre[j];
            }
            pre = cur;
        }
        return pre;
    }
};
```
**进一步优化**

能否只用一个数组呢？
![[Pasted image 20240113204149.png]]
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1);
        row[0] = 1;
        for (int i = 1; i <= rowIndex; ++i) {
            for (int j = i; j > 0; --j) {
                row[j] += row[j - 1];
            }
        }
        return row;
    }
};
```
#### 方法二：线性递推
![[Pasted image 20240113204248.png]]
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1);
        row[0] = 1;
        for (int i = 1; i <= rowIndex; ++i) {
            row[i] = 1LL * row[i - 1] * (rowIndex - i + 1) / i;
        }
        return row;
    }
};
```
