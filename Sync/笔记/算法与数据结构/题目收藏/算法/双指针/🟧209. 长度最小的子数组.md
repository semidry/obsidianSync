[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/)
### 问题描述
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的连续子数组` [numsl, numsl+1, ..., numsr-1, numsr] `，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：

> 输入：target = 7, nums = `[2,3,1,2,4,3]`
> 输出：2
> 解释：子数组` [4,3]` 是该条件下的长度最小的子数组。


示例 2：

> 输入：target = 4, nums =` [1,4,4]`
> 输出：1


示例 3：

> 输入：target = 11, nums = `[1,1,1,1,1,1,1,1]`
> 输出：0

### 解答
#### 方法二：前缀和+二分查找
#前缀和 #二分
方法一的时间复杂度是 $O (n^2)$，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要 $O (n)$ 的时间。如果使用二分查找，则可以将时间优化到 $O (logn)$。

为了使用二分查找，需要额外创建一个数组 `sums` 用于存储数组 `nums` 的前缀和，其中 `sums[i]` 表示从 `nums [0]` 到 `nums[i-1]` 的元素和。得到前缀和之后，对于每个开始下标 i ，可通过二分查找得到大于或等于的最小下标 `bound`，使得 `sums[bound]` - `sums[i-1]` `>= s`，并更新子数组的最小长度 (此时子数组的长度是 `bound-(i-1)`)。

因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            if (bound != sums.end()) {
                ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

### 方法三：滑动窗口
#滑动窗口 #双指针 
在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高。为了降低时间复杂度，可以使用滑动窗口的方法。

定义两个指针 `start` 和 `end` 分别表示子数组 (滑动窗窗)的开始位置和结束位置，维护变量 `sum` 存储子数组中的元素和 (即从 `numsstart` 到 `numsend` 的元素和)

初始状态下，`start` 和 `end` 都指向下标 0，`sum` 的值为 0。

每一轮迭代，将 `numsl[end]` 加到 `sum`，如果 `sum>=s`，则更新子数组的最小长度 (此时子数组的长度是 `end-start+1`)，然后将 `nums[start]`  从 `sum` 中减去并将 `start` 右移, 直到 `sum<s`，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 `end` 右移。
```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```
#### 复杂度分析

时间复杂度：$O (n)$，其中 n 是数组的长度。指针 $\textit{start}$ 和 $\textit{end}$ 最多各移动 n 次。

空间复杂度：$O (1)$。
