#目录 

### 数组和字符串
[数组和字符串 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/array-and-string/xkhi75/)
> [[🟧167. 两数之和 II - 输入有序数组]]
> [[🟧209. 长度最小的子数组]]
> [[🟩349. 两个数组的交集]]
> [[🟧424. 替换后的最长重复字符]]
> [[🟧1004. 最大连续1的个数 III]]
> [[🟧159. 至多包含两个不同字符的最长子串]]
> [[🟩LCR 141. 训练计划 III（链表反转）]]

### 双指针技巧情景一
在上一章中，我们通过迭代数组来解决一些问题。通常，我们只需要一个指针进行迭代，即从数组中的第一个元素开始，最后一个元素结束。然而，有时我们会使用两个指针进行迭代。
![[Pasted image 20240112101518.png]]
#### 示例
让我们从一个经典问题开始：

反转数组中的元素。比如数组为` ['l', 'e', 'e', 't', 'c', 'o', 'd', 'e']`，反转之后变为 `['e', 'd', 'o', 'c', 't', 'e', 'e', 'l']`。

使用双指针技巧，其思想是分别将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。
#### 小结
我们来总结一下，使用双指针的典型场景之一是你想要

> 从两端向中间迭代数组。

这时你可以使用双指针技巧：

> 一个指针从头部开始，而另一个指针从尾部开始。

这种技巧经常在排序数组中使用。

```python
def reverseString(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1
```


### 双指针技巧情景二
有时，我们可以使用两个不同步的指针来解决问题，即快慢指针。与情景一不同的是，两个指针的运动方向是相同的，而非相反。

#### 示例
让我们从一个经典问题开始：

> 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

如果我们没有空间复杂度上的限制，那就更容易了。我们可以初始化一个新的数组来存储答案。如果元素不等于给定的目标值，则迭代原始数组并将元素添加到新的数组中。
![[Pasted image 20240112101241.png]]

实际上，它相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置。

#### 考虑空间限制
如果我们不使用额外的数组，只是在原数组上进行操作呢？

此时，我们就可以采用快慢指针的思想：初始化一个快指针 fast 和一个慢指针 slow，fast 每次移动一步，而 slow 只当 fast 指向的值不等于 val 时才移动一步。
![[353657e00bf49ad5c6aeb8e97414d1d610083acdb580e7c2b0fe036a523129f5-4.gif]]

以下代码供你参考：

```python
def removeElement(self, nums: List[int], val: int) -> int:
    slow = 0
    n = len(nums)
    for fast in range(n):
        if nums[fast] != val:
            nums[slow] = nums[fast]
            slow += 1
    return slow
```

 

#### 小结
这是你需要使用双指针技巧的另一种非常常见的情况：

> 同时有一个慢指针和一个快指针。

解决这类问题的关键是:

> 确定两个指针的移动策略。

与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心法则来决定你的运动策略。