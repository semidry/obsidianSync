[159. 至多包含两个不同字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solutions/2388233/zhi-duo-bao-han-liang-ge-bu-tong-zi-fu-d-dqii/)

> [!info] 题目
> 给你一个字符串 `s` ，请你找出 **至多** 包含 **两个不同字符** 的最长子串，并返回该子串的长度。

> [!cite] 示例 1
> **输入：**s = "eceba"
**输出：**3
**解释：**满足题目要求的子串是 "ece" ，长度为 3 。

> [!cite] 示例 2
> **输入：**s = "ccaabbb"
> **输出：**5
> **解释：**满足题目要求的子串是 "aabbb" ，长度为 5 。

> [!help] 提示
> - 1 <= `s.length` <= $10^5$
> - `s` 由英文字母组成

### 方法一：滑动窗口
#滑动窗口 #双指针
**思路**
为了一次性解决问题， 我们使用滑动窗口方法，设定两个指针 $\textit{left}$ 和 $\textit{right}$ 作为窗口的边界。
思路是，将两个指针都设定在位置 $\textit{0}$， 然后向右移动 $\textit{right}$ 指针，直到 窗口内不超过两个不同的字符。 如果某一点我们得到了 $\textit{3}$ 个不同的字符， 那么需要移动 $\textit{left}$ 指针，窗口里最多只能有 $\textit{2}$ 个不同的字符。
![[Pasted image 20240116150951.png]]
这就是算法概括：沿着字符窗口移动，窗口中不超过 $\textit{2}$ 个不同的字符，并在每一步更新最大子字符串长度。

> 还有一个问题需要回答 —— 如何移动左指针以保证字符串中只有 $\textit{2}$ 个不同的字符？

我们可以建立一个哈希表，键是滑动窗口中的所有字符，值是它们最右端的位置。在每一刻，这个哈希表最多只能包含 $\textit{3}$ 个元素。

![[Pasted image 20240116151059.png]]

比如，使用此哈希表，我们知道字符 $\text{`e'}$ 在 $\text{``eeeeeeeet"}$ 窗口的最右位置是 $\text{8}$，所以需要将 $\textit{left}$ 指针移动到 $\text{8 + 1 = 9}$ 的位置，从滑动窗口中排除字符 $\text{`e'}$。
这个算法的最优时间复杂度？——当它只需要一次穿越长度为 $\text{N}$ 的字符串，时间复杂度是 $\mathcal{O}(N)$。

**算法**
现在我们可以写出算法。
- 如果字符串长度$\text{N}$ 小于 $\text{3}$，则返回 $\textit{N}$。
- 将两个指针都设置在字符串开始 $\textit{left = 0}$ 和 $\text{right = 0}$ 的位置，初始化最大子字符串长度 $\textit{maxlen = 2}$。
- 当 $\textit{right}$ 指针小于 $\text{N}$ 时：
	- 如果哈希表包含少于 $\text{3}$ 个不同的字符， 将当前字符 $\textit{s[right]}$ 添加到哈希表中， 并将 $\textit{right}$ 指针向右移动。
	- 如果哈希表包含 $\text{3}$ 个不同的字符， 从哈希表中删除最左侧的字符 并移动 $\textit{left}$ 指针，使得滑动窗口再次仅包含 $\text{2}$ 个不同的字符。
	- 更新 $\textit{maxlen}$。

```cpp
class Solution {
public:
   int lengthOfLongestSubstringTwoDistinct(string s) {
       size_t n = s.length();
       if (n < 3) {
           return n;
       }

       // 滑动窗口的左右指针
       int left = 0, right = 0;
       // hashmap 中的字符 -> 它在滑动窗口中最靠右的位置
       map<char, int> hashmap;

       int max_len = 2;

       while (right < n) {
           // 当滑动窗口包含小于 3 个字符
           hashmap[s[right]] = right;
           right++;

           // 滑动窗口包含 3 个字符
           if (hashmap.size() == 3) {
               int del_idx = INT_MAX;
               for (pair<char, int> element : hashmap) {
                   del_idx = min(del_idx, element.second);
               }
               // 删除最左边的字符
               hashmap.erase(s[del_idx]);
               left = del_idx + 1;
           }
           max_len = max(max_len, right - left);
       }
       return max_len;
   }
};
```

我的代码
```cpp
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int book[128] = {0};
        int l = 0, r = 0, n = s.size(), cnt = 0, ans = 0;

        while (r < n) {
            if (book[s[r]] == 0) {
                cnt++;
            }
            book[s[r]]++;

            while (cnt > 2) {
                book[s[l]]--;
                if (book[s[l]] == 0) {
                    cnt--;
                }
                l++;
            }

            ans = max(ans, r - l + 1);
            r++;
        }

        return ans;
    }
};

```
