[LCR 130. 衣橱整理 - 力扣（LeetCode）](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/)
#剪枝 
> [!info] 题目
> 家居整理师将待整理衣橱划分为 `m x n` 的二维矩阵 `grid`，其中 `grid[i][j]` 代表一个需要整理的格子。整理师自 `grid[0][0]` 开始 **逐行逐列** 地整理每个格子。
整理规则为：在整理过程中，可以选择 **向右移动一格** 或 **向下移动一格**，但不能移动到衣柜之外。同时，不需要整理 `digit(i) + digit(j) > cnt` 的格子，其中 `digit(x)` 表示数字 `x` 的各数位之和。
请返回整理师 **总共需要整理多少个格子**。

> [!cite] 示例 1
> **输入：**m = 4, n = 7, cnt = 5
**输出：**18

> [!cite] 示例 2
> 

> [!help] 提示
> - `1 <= n, m <= 100`
> - `0 <= cnt <= 20`

**数位和计算**：
```cpp
int digit(int x){
        int res=0;
        while(x>0){
            res+=x%10;
            x/=10;
        }
        return res;
    }
```
只求增量时可化简为三元表达式：
```cpp
(x + 1) % 10 != 0 ? s_x + 1 : s_x - 8;
```
### 方法一
> [!example] 深度优先搜索
#深度优先搜索 

> [!success] 代码：
```cpp
class Solution {
public:
    int wardrobeFinishing(int m, int n, int cnt) {
        this->m=m;
        this->n=n;
        vector<vector<bool>> visited(m,vector(n,false));
        return dfs(0,0,cnt,visited);
    }
private:
    int m,n;
    int dfs(int i,int j,int cnt,vector<vector<bool>> &visited){
        if(i==m||j==n||digit(i)+digit(j)>cnt||visited[i][j]) return 0;
        visited[i][j]=true;
        return 1+dfs(i+1,j,cnt,visited)+dfs(i,j+1,cnt,visited);

    }

    int digit(int x){
        int res=0;
        while(x>0){
            res+=x%10;
            x/=10;
        }
        return res;
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(MN)$
> - **空间复杂度**：$O(MN)$


> [!example] 广度优先搜索
> #广度优先搜索 

> [!success] 代码：
```cpp
class Solution {
public:
    int wardrobeFinishing(int m, int n, int cnt) {
        vector<vector<bool>> visited(m, vector<bool>(n, 0));
        int res = 0;
        queue<vector<int>> que;
        que.push({ 0, 0, 0, 0 });
        while(que.size() > 0) {
            vector<int> x = que.front();
            que.pop();
            int i = x[0], j = x[1], si = x[2], sj = x[3];
            if(i >= m || j >= n || cnt < si + sj || visited[i][j]) continue;
            visited[i][j] = true;
            res++;
            que.push({ i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj });
            que.push({ i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8 });
        }
        return res;
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(MN)$
> - **空间复杂度**：$O(MN)$