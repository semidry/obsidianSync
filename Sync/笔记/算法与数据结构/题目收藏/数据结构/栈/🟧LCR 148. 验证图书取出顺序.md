[LCR 148. 验证图书取出顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/)
本题与主站 946 题相同：[946. 验证栈序列 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-stack-sequences/description/)
#栈 
> [!info] 题目
> 现在图书馆有一堆图书需要放入书架，并且图书馆的书架是一种特殊的数据结构，只能按照 **一定** 的顺序 **放入** 和 **拿取** 书籍。
给定一个表示图书放入顺序的整数序列 `putIn`，请判断序列 `takeOut` 是否为按照正确的顺序拿取书籍的操作序列。你可以假设放入书架的所有书籍编号都不相同。

> [!cite] 示例 1
> **输入：**putIn = `[6,7,8,9,10,11]`, takeOut = `[9,11,10,8,7,6]`
**输出：**true
**解释：**我们可以按以下操作放入并拿取书籍：
push(6), push(7), push(8), push(9), pop() -> 9,
push(10), push(11),pop() -> 11,pop() -> 10, pop() -> 8, pop() -> 7, pop() -> 6

> [!cite] 示例 2
> **输入：**putIn = `[6,7,8,9,10,11]`, takeOut = `[11,9,8,10,6,7]`
**输出：**false
**解释：**6 不能在 7 之前取出。

> [!help] 提示
> - `0 <= putIn.length == takeOut.length <= 1000`
>- `0 <= putIn[i], takeOut < 1000`
>- `putIn` 是 `takeOut` 的排列。
### 方法一
> [!example] 

1. **初始化**： 辅助栈 stack ，拿取序列的索引 i ；
2. **遍历压栈序列**： 各元素记为 num ；
	1. 元素 num 入栈；
	2. 循环出栈：若 stack 的栈顶元素 == 拿取序列元素 takeOut[i] ，则执行出栈与 i++ ；
3. **返回值**： 若 stack 为空，则此拿取序列合法。

> [!success] 代码：
```cpp
class Solution {
public:
    bool validateBookSequences(vector<int>& putIn, vector<int>& takeOut) {
        stack<int> stk;
        int i = 0;
        for(int num : putIn) {
            stk.push(num); // num 入栈
            while(!stk.empty() && stk.top() == takeOut[i]) { // 循环判断与出栈
                stk.pop();
                i++;
            }
        }
        return stk.empty();
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(N)$
> - **空间复杂度**：$O(N)$

