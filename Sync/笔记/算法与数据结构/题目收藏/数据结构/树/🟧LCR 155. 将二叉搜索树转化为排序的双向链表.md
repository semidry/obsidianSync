---
dg-publish: true
---
[LCR 155. 将二叉搜索树转化为排序的双向链表 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/)
本题与主站 426 题相同：[426. 将二叉搜索树转化为排序的双向链表 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/description/)
#树 #二叉搜索树 #中序遍历 #链表 #递归 

> [!info] 题目
> 
将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。
对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

> [!cite] 示例 1
> **输入：**root = `[4,2,5,1,3] `
![[Pasted image 20240122122928.png]]
**输出`：**[1,2,3,4,5]`
**解释：**下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。
![[Pasted image 20240122122944.png]]

> [!cite] 示例 2
> **输入：**root = `[]`
**输出：`**[]`
**解释：**输入是空树，所以输出也是空链表。

> [!help] 提示
> - `-1000 <= Node.val <= 1000`
>- `Node.left.val < Node.val < Node.right.val`
>- `Node.val` 的所有值都是独一无二的
>- `0 <= Number of Nodes <= 2000`
### 方法一
> [!example] 

**解题思路**：
本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。
将“二叉搜索树”转换成一个 “排序的循环双向链表” ，其中包含三个要素：
1. 排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。
2. 双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。
3. 循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。
![[Pasted image 20240122123207.png]]
根据以上分析，考虑使用中序遍历访问树的各节点 cur ；并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。

**算法流程**：
`dfs(cur)`: 递归法中序遍历；

1. 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；
2. 递归左子树，即 dfs(cur.left) ；
3. 构建链表：
	1. 当 pre 为空时： 代表正在访问链表头节点，记为 head ；
	2. 当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ，cur.left = pre ；
	3. 保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；
4. 递归右子树，即 dfs(cur.right) ；

`treeToDoublyList(root)`：

1. 特例处理： 若节点 root 为空，则直接返回；
2. 初始化： 空节点 pre ；
3. 转化为双向链表： 调用 dfs(root) ；
4. 构建循环链表： 中序遍历完成后，head 指向头节点，pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；
5. 返回值： 返回链表的头节点 head 即可；

> [!success] 代码：
```cpp
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        dfs(root);
        head->left = pre;
        pre->right = head;
        return head;
    }
private:
    Node *pre, *head;
    void dfs(Node* cur) {
        if(cur == nullptr) return;
        dfs(cur->left);
        if(pre != nullptr) pre->right = cur;
        else head = cur;
        cur->left = pre;
        pre = cur;
        dfs(cur->right);
    }
};
```
> [!attention] 复杂度
>- **时间复杂度** $O(N)$ ： N 为二叉树的节点数，中序遍历需要访问所有节点。
>- **空间复杂度** $O(N)$ ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。

