---
dg-publish: true
---
[LCR 176. 判断是否为平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/)
本题与主站 110 题相同：[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)
#平衡二叉树 #树 #递归 

> [!info] 题目
> 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

> [!cite] 示例 1
> **输入：**root = `[3,9,20,null,null,15,7]`
**输出：**true 
**解释：**如下图
![[Pasted image 20240122130106.png]]

> [!cite] 示例 2
> 输入：root = `[1,2,2,3,3,null,null,4,4]`
输出：false
解释：如下图
![[Pasted image 20240122130127.png]]

> [!help] 提示
> - `0 <= 树的结点个数 <= 10000`
### 方法一
> [!example] 后序遍历 + 剪枝 （从底至顶）
#剪枝 
以下两种方法均基于以下性质推出： 此树的深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1+1+1 。
此方法为本题的最优解法，但剪枝的方法不易第一时间想到。
思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。

**算法流程**：
`recur(root)` 函数：
- 返回值：
	1. 当节点 `root` 左 / 右子树的深度差$\leq 1$ ：则返回当前子树的深度，即节点 `root` 的左 / 右子树的深度最大值 +1 （ $max(left, right) + 1$ ）；
	2. 当节点 `root` 左 / 右子树的深度差$> 1$ ：则返回 −1 ，代表 此子树不是平衡树 。
- 终止条件：
	1. 当 root 为空：说明越过叶节点，因此返回高度 0 ；
	2. 当左（右）子树深度为 −1 ：代表此树的 左（右）子树 不是平衡树，因此剪枝，直接返回 −1 ；
`isBalanced(root)` 函数：
- 返回值： 若 recur(root) != -1 ，则说明此树平衡，返回 $\text{true}$ ； 否则返回 $\text{false}$ 。


> [!success] 代码：
```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return recur(root) != -1;
    }
private:
    int recur(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = recur(root->left);
        if(left == -1) return -1;
        int right = recur(root->right);
        if(right == -1) return -1;
        return abs(left - right) < 2 ? max(left, right) + 1 : -1;
    }
};
```
> [!attention] 复杂度
**时间复杂度** $O(N)$： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。
**空间复杂度** $O(N)$： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。


> [!example]  先序遍历 + 判断深度 （从顶至底）

我的笨方法
> [!success] 代码：
```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        return isBalanced(root->left)&&isBalanced(root->right)&&abs(height(root->left)-height(root->right))<=1;

    }

    int height(TreeNode* node){
        if(!node) return 0;
        return 1+max(height(node->left),height(node->right));
    }
};
```
> [!attention] 复杂度
**时间复杂度** $O(NlogN)$： 最差情况下（为 “满二叉树” 时），isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历 各子树的所有节点 。
满二叉树高度的复杂度 O(logN)O(log N)O(logN) ，将满二叉树按层分为 log (N+1)log(N+1) 层；
通过调用 depth(root) ，判断二叉树各层的节点的对应子树的深度，需遍历节点数量为 $N \times 1, \frac{N-1}{2} \times 2, \frac{N-3}{4} \times 4, \frac{N-7}{8} \times 8, ..., 1 \times \frac{N+1}{2}$  。因此各层执行 depth(root) 的时间复杂度为 O(N) （每层开始，最多遍历 N 个节点，最少遍历 $\frac{N+1}{2}$ 个节点）。
其中，$\frac{N-3}{4} \times 4$ 代表从此层开始总共需遍历 $N-3$ 个节点，此层共有 4 个节点，因此每个子树需遍历 $\frac{N-3}{4}$ 个节点。
因此，总体时间复杂度 === 每层执行复杂度 ×\times× 层数复杂度 = $O(N \times \log N)$ 。
![[Pasted image 20240122130745.png]]
**空间复杂度$O(N)$：** 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。

