[LCR 143. 子结构判断 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/)
#树 
> [!info] 题目
> 给定两棵二叉树 `tree1` 和 `tree2`，判断 `tree2` 是否以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。  
注意，**空树** 不会是以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。

> [!cite] 示例 1
> ![[Pasted image 20240121222835.png]]
> **输入：**tree1 = [1,7,5], tree2 = [6,1]
**输出：**false
**解释：**tree2 与 tree1 的一个子树没有相同的结构和节点值。

> [!cite] 示例 2
> ![[Pasted image 20240121222850.png]]
> **输入：**tree1 = [3,6,7,1,8], tree2 = [6,1]
**输出：**true
**解释：**tree2 与 tree1 的一个子树拥有相同的结构和节点值。即 6 - > 1。

> [!help] 提示
> 0 <= 节点个数 <= 10000
### 方法一
#递归 
> [!example] 

**解题思路：**
若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：
1. 先序遍历树 A 中的每个节点 node ；（对应函数 isSubStructure(A, B)）
2. 判断树 A 中以 node 为根节点的子树是否包含树 B 。（对应函数 recur(A, B)）

![[Pasted image 20240121222922.png]]
**算法流程：**
本文名词规定：树 A 的根节点记作 节点 A ，树 B 的根节点称为 节点 B 。

`recur(A, B) `函数：
1. 终止条件：
	1. 当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true\text{true}true ；
	2. 当节点 A 为空：说明已经越过树 A 的叶节点，即匹配失败，返回 false\text{false}false ；
	3. 当节点 A 和 B 的值不同：说明匹配失败，返回 false\text{false}false ；
2. 返回值：
	1. 判断 A 和 B 的 左子节点 是否相等，即 recur(A.left, B.left) ；
	2. 判断 A 和 B 的 右子节点 是否相等，即 recur(A.right, B.right) ；

`isSubStructure(A, B) `函数：
1. 特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false\text{false}false ；
2. 返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；
	1. 以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；
	2. 树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；
	3. 树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；

> [!success] 代码：
```cpp
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        return (A != nullptr && B != nullptr) && (recur(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B));
    }
private:
    bool recur(TreeNode* A, TreeNode* B) {
        if(B == nullptr) return true;
        if(A == nullptr || A->val != B->val) return false;
        return recur(A->left, B->left) && recur(A->right, B->right);
    }
};
```
> [!attention] 复杂度
> - 时间复杂度$ O(MN)$ ： 其中 M, N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。
> - 空间复杂度 $O(M)$ ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当$ M \leq N$ 时，遍历树 A 与递归判断的总递归深度为 M ；当 $M>N$ 时，最差情况为遍历至树 A 的叶节点，此时总递归深度为 M。