[LCR 193. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/)
本题与主站 235 题相同：[235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)
#二叉搜索树 #树 
> [!info] 题目
> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

> [!cite] 示例 1
> **输入:** root = `[6,2,8,0,4,7,9,null,null,3,5]`, p = 2, q = 8
**输出:** 6 
**解释:** 节点 `2` 和节点 `8` 的最近公共祖先是 `6。`

> [!cite] 示例 2
> **输入:** root = `[6,2,8,0,4,7,9,null,null,3,5]`, p = 2, q = 4
**输出:** 2
**解释:** 节点 `2` 和节点 `4` 的最近公共祖先是 `2`, 因为根据定义最近公共祖先节点可以为节点本身。

> [!help] 提示
> - 所有节点的值都是唯一的。
> - p、q 为不同节点且均存在于给定的二叉搜索树中。


**解题思路**：
> 祖先的定义： 若节点 p 在节点 root 的左（右）子树中，或 p = root，则称 root 是 p 的祖先。

> 最近公共祖先的定义： 设节点 root 为节点 p , q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p , q 的公共祖先，则称 root 是 “最近的公共祖先” 。

![[Pasted image 20240122141600.png]]

根据以上定义，若 root 是 p , q 的 最近公共祖先 ，则只可能为以下三种情况之一：
- p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
- p = root 且 q 在 root 的左或右子树中；
- q = root 且 p 在 root 的左或右子树中；

![[Pasted image 20240122141617.png]]
本题给定了两个重要条件：(1) 树为 二叉搜索树 ，(2) 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p , q 与 root 的子树关系，即：
- 若 root.val < p.val ，则 p 在 root 右子树 中；
- 若 root.val > p.val ，则 p 在 root 左子树 中；
- 若 root.val = p.val ，则 p 和 root 指向 同一节点 ；
### 方法一
> [!example] 迭代

#迭代

1. 循环搜索： 当节点 root 为空时跳出；
	1. 当 p, q 都在 root 的 右子树 中，则遍历至 root.right ；
	2. 否则，当 p , q 都在 root 的 左子树 中，则遍历至 root.left ；
	3. 否则，说明找到了 最近公共祖先 ，跳出；
2. 返回值： 最近公共祖先 root ；
> [!success] 代码：
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(p->val > q->val)
            swap(p, q);
        while(root != nullptr) {
            if(root->val < p->val) // p,q 都在 root 的右子树中
                root = root->right; // 遍历至右子节点
            else if(root->val > q->val) // p,q 都在 root 的左子树中
                root = root->left; // 遍历至左子节点
            else break;
        }
        return root;
    }
};
```
> [!attention] 复杂度
**时间复杂度** $O(N)$ ： 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 $\log N$ （满二叉树），最大为 $N$ （退化为链表）。
**空间复杂度** $O(1)$ ： 使用常数大小的额外空间。
### 方法二
> [!example] 递归

#递归 
1. 递归工作
	1. 当 p , q 都在 root 的 右子树 中，则开启递归 root.right 并返回；
	2. 否则，当 p , q 都在 root 的 左子树 中，则开启递归 root.left 并返回；
2. 返回值： 最近公共祖先 root ；
> [!success] 代码：
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root->val < p->val && root->val < q->val)
            return lowestCommonAncestor(root->right, p, q);
        if(root->val > p->val && root->val > q->val)
            return lowestCommonAncestor(root->left, p, q);
        return root;
    }
};
```
> [!attention] 复杂度
**时间复杂度** $O(N)$ ： 其中 $N$ 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 $\log N$ （满二叉树），最大为 $N$ （退化为链表）。
**空间复杂度** $O(N)$ ： 最差情况下，即树退化为链表时，递归深度达到树的层数 $N$ 。

