---
dg-publish: true
---
[LCR 191. 按规则计算统计结果 - 力扣（LeetCode）](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/)
#数组 
> [!info] 题目
> 为了深入了解这些生物群体的生态特征，你们进行了大量的实地观察和数据采集。数组 `arrayA` 记录了各个生物群体数量数据，其中 `arrayA[i]` 表示第 `i` 个生物群体的数量。请返回一个数组 `arrayB`，该数组为基于数组 `arrayA` 中的数据计算得出的结果，其中 `arrayB[i]` 表示将第 `i` 个生物群体的数量从总体中排除后的其他数量的乘积。

> [!cite] 示例 1
> **输入：**arrayA =` [2, 4, 6, 8, 10]`
**输出：**`[1920, 960, 640, 480, 384]`

> [!cite] 示例 2
>  **输入：**arrayA =`[1, 2, 0, 4, 5]`
**输出：**`[0,0,40,0,0]`

> [!help] 提示
> - 所有元素乘积之和不会溢出 32 位整数
> - `arrayA.length <= 100000`
### 方法一
> [!example] 

本题的难点在于 不能使用除法 ，即需要 只用乘法 生成数组 B 。根据题目对 B[i] 的定义，可列如下图所示的表格。

根据表格的主对角线（全为 1 ），可将表格分为 上三角 和 下三角 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 不使用除法 就获得结果。

![[Pasted image 20240119104918.png]]
> [!success] 代码：
```cpp
class Solution {
public:
    vector<int> statisticalResult(vector<int>& arrayA) {
        int len = arrayA.size();
        if(len == 0) return {};
        vector<int> arrayB(len, 1);
        arrayB[0] = 1;
        int tmp = 1;
        for(int i = 1; i < len; i++) {
            arrayB[i] = arrayB[i - 1] * arrayA[i - 1];
        }
        for(int i = len - 2; i >= 0; i--) {
            tmp *= arrayA[i + 1];
            arrayB[i] *= tmp;
        }
        return arrayB;
    }
};
```
> [!attention] 复杂度
> **时间复杂度** O(N) ： 其中 N 为数组长度，两轮遍历数组 A ，使用 O(N) 时间。
**空间复杂度** O(1) ： 变量 tmp 使用常数大小额外空间（数组 B 作为返回值，不计入复杂度考虑）。

