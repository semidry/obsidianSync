---
dg-publish: true
---
[LCR 180. 文件组合 - 力扣（LeetCode）](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/)

#数组
> [!info] 题目
> 待传输文件被切分成多个部分，按照原排列顺序，每部分文件编号均为一个 **正整数**（至少含有两个文件）。传输要求为：连续文件编号总和为接收方指定数字 `target` 的所有文件。请返回所有符合该要求的文件传输组合列表。
> **注意**，返回时需遵循以下规则：
> - 每种组合按照文件编号 **升序** 排列；
> - 不同组合按照第一个文件编号 **升序** 排列。

> [!cite] 示例 1
> **输入：**target = 12
**输出：**`[[3, 4, 5]]`
**解释：**在上述示例中，存在一个连续正整数序列的和为 12，为 `[3, 4, 5]`。

> [!cite] 示例 2
> **输入：**target = 18
**输出：**`[[3,4,5,6],[5,6,7]]`
**解释：**在上述示例中，存在两个连续正整数序列的和分别为 18，分别为` [3, 4, 5, 6] `和 `[5, 6, 7]`。

> [!help] 提示
> - `1 <= target <= 10^5`
### 方法一
#数学 
> [!example] 求和公式

$$
target = \frac { ( i + j ) \times ( j - 1 + 1 ) } { 2 }
$$
$$
j = \frac { - 1 + \sqrt { 1 + 4 ( 2 * target + i ^ { 2 } - i ) } } { 2 }
$$
> [!success] 代码：
```cpp
//计算公式中 i^2 项可能超过 int 类型取值范围，因此在 C++ 中需要转化成 long 类型。
class Solution {
public:
    vector<vector<int>> fileCombination(int target) {
        int i = 1;
        double j = 2.0;
        vector<vector<int>> res;
        while(i < j) {
            j = (-1 + sqrt(1 + 4 * (2 * target + (long) i * i - i))) / 2;
            if(i < j && j == (int)j) {
                vector<int> ans;
                for(int k = i; k <= (int)j; k++)
                    ans.push_back(k);
                res.push_back(ans);
            }
            i++;
        }
        return res;
    }
};
```
> [!attention] 复杂度
> 时间复杂度 O(N) 
空间复杂度 O(1) 

### 方法二
#滑动窗口 #双指针 
> [!example] 滑动窗口

设连续正整数序列的左边界 i 和右边界 j ，则可构建滑动窗口从左向右滑动。循环中，每轮判断滑动窗口内元素和与目标值 target 的大小关系，若相等则记录结果，若大于 target 则移动左边界 i （以减小窗口内的元素和），若小于 target 则移动右边界 j （以增大窗口内的元素和）。
> [!success] 代码：
```cpp
class Solution {
public:
    vector<vector<int>> fileCombination(int target) {
        int i = 1, j = 2, s = 3;
        vector<vector<int>> res;
        while(i < j) {
            if(s == target) {
                vector<int> ans;
                for(int k = i; k <= j; k++)
                    ans.push_back(k);
                res.push_back(ans);
            }
            if(s >= target) {
                s -= i;
                i++;
            } else {
                j++;
                s += j;
            }
        }
        return res;
    }
};
```
> [!attention] 复杂度
> - 时间复杂度：O(N)
> - 空间复杂度：O(1)



