---
dg-publish: true
---
[48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/description/)
#矩阵 
### 描述
给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
#数组 
**示例 1:**

> 给定 matrix = 
> [
>   `[1,2,3],`
>  ` [4,5,6],`
>  ` [7,8,9]`
> ],
> 
> 原地旋转输入矩阵，使其变为:
> [
>   `[7,4,1],`
>  ` [8,5,2],`
>  ` [9,6,3]`
> ]

**示例 2:**

> 给定 matrix =
> [
>  ` [ 5, 1, 9,11],`
>  ` [ 2, 4, 8,10],`
>  ` [13, 3, 6, 7],`
>  ` [15,14,12,16]`
> ], 
> 
> 原地旋转输入矩阵，使其变为:
> [
> `  [15,13, 2, 5],`
> `  [14, 3, 4, 1],`
> `  [12, 6, 8, 9],`
> `  [16, 7,10,11]`
> ]
### 方法一：使用辅助数组
### 方法二：原地旋转
#数学 
$$
\begin{cases}  
temp\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space=matrix[row][col]\\
matrix[row][col]\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space=matrix[n-col-1][row]\\
matrix[n-col-1][row]\space\space\space\space\space\space\space\space\space\space\space\space\space\space=matrix[n-row-1][n-col-1]\\
matrix[n-row-1][n-col-1]=matrix[col][n-row-1]\\
matrix[col][n-row-1]\space\space\space\space\space\space\space\space\space\space\space\space\space\space=temp
\end{cases}
$$
当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col)(\textit{row}, \textit{col})(row,col) 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：

当 nnn 为偶数时，我们需要枚举 $n^2/4=(n/2) \times (n/2)$个位置，可以将该图形分为四块，以 4×4的矩阵为例：
![[Pasted image 20240105224746.png]]
保证了不重复、不遗漏；

当 n 为奇数时，由于中心的位置经过旋转后位置不变，我们需要枚举 $(n^2-1) / 4 = ((n-1)/2) \times ((n+1)/2)$个位置，需要换一种划分的方式，以 5×5的矩阵为例：
![[Pasted image 20240105224756.png]]同样保证了不重复、不遗漏，矩阵正中央的点无需旋转。
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
};

```
### 方法三：用翻转代替旋转
#数学 
一次水平翻转，一次主对角线翻转。
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```
