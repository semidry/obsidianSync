[LCR 121. 寻找目标值 - 二维数组 - 力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/)
本题与主站 240 题相同：[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/)
#查找 #矩阵 
> [!info] 题目
> `m`*`n` 的二维数组 `plants` 记录了园林景观的植物排布情况，具有以下特性：
> - 每行中，每棵植物的右侧相邻植物不矮于该植物；
> - 每列中，每棵植物的下侧相邻植物不矮于该植物。
请判断 `plants` 中是否存在目标高度值 `target`。

> [!cite] 示例 1
> **输入：**plants = [[2,3,6,8],[4,5,8,9],[5,9,10,12]], target = 8
**输出：**true

> [!cite] 示例 2
> **输入：**plants = [[1,3,5],[2,5,7]], target = 4
**输出：**false

> [!help] 提示
> - `0 <= n <= 1000`
> - `0 <= m <= 1000`
### 方法一
> [!example] 

如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。

因此，考虑从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。
![[Pasted image 20240123153643.png]]
算法流程：
“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素。以 plants 中的 左下角元素 为起始点，则有:
1. 从矩阵 plants 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：
	1. 当 `plants[i][j]` > target 时，执行 i-- ，即消去第 i 行元素；
	2. 当 `plants[i][j]` < target 时，执行 j++ ，即消去第 j 列元素；
	3. 当 `plants[i][j]` = target 时，返回 true ，代表找到目标值。
2. 若行索引或列索引越界，则代表矩阵中无目标值，返回 false 。
每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素，因此可重复使用以上性质消去行（列）。

> [!success] 代码：
```cpp
class Solution {
public:
    bool findTargetIn2DPlants(vector<vector<int>>& plants, int target) {
        int i = plants.size() - 1, j = 0;
        while(i >= 0 && j < plants[0].size())
        {
            if(plants[i][j] > target) i--;
            else if(plants[i][j] < target) j++;
            else return true;
        }
        return false;
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(M+N)$
> - **空间复杂度**：$O(1)$

