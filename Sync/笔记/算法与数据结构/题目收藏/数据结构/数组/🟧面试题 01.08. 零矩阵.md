### 描述
编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
示例 1：
#数组 
> 输入：
> [
> `  [1,1,1],`
> `  [1,0,1],`
> `  [1,1,1]`
> ]
> 输出：
> [
> `  [1,0,1],`
> `  [0,0,0],`
> `  [1,0,1]`
> ]

示例 2：

> 输入：
> [
> `  [0,1,2,0],`
> `  [3,4,5,2],`
> `  [1,3,1,5]`
> ]
> 输出：
> [
> `  [0,0,0,0],`
> `  [0,4,5,0],`
> `  [0,3,1,0]`
> ]

### 解答
#### 方法一：使用标记数组
思路和算法

我们可以用两个标记数组分别记录每一行和每一列是否有零出现。

具体地，我们首先遍历该数组一次，如果某个元素为 000，那么就将该元素所在的行和列所对应标记数组的位置置为true。最后我们再次遍历该数组，用标记数组更新原数组即可。
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> row(m), col(n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!matrix[i][j]) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
};
```
#### 方法二：使用两个标记变量
思路和算法

我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1)的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。

在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        int flag_col0 = false, flag_row0 = false;
        for (int i = 0; i < m; i++) {
            if (!matrix[i][0]) {
                flag_col0 = true;
            }
        }
        for (int j = 0; j < n; j++) {
            if (!matrix[0][j]) {
                flag_row0 = true;
            }
        }
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (!matrix[i][j]) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (!matrix[i][0] || !matrix[0][j]) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        if (flag_col0) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
        if (flag_row0) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
    }
};
```
#### 方法三：使用一个标记变量
思路和算法

我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。
```cpp
 public void setZeroes(int[][] matrix) {
        //用原数组的第一行和第一列来记录对应的行列是否有出现0元素；
       //可以通过两个元素来记录是否原先首行首列就有0元素（因为在用首行首列记录0元素的时候，可能本身没有，后续更新以后就有了）
       //但是如果我们最后更新元素的时候从行末往行首更新的话，那就能确保首列的第一个元素是最后才被更新到的
       //那么只要首列的第一个元素是0，就说明原先该元素就是0，也就意味着首行本来就有0元素，所以标志变量就可以采用1个
       boolean colFlag=false;
       int m=matrix.length;
       int n=matrix[0].length;
       for(int i=0;i<m;i++){
           if(matrix[i][0]==0){
               //首列出现过0元素
               colFlag=true;
           }
           for(int j=1;j<n;j++){
               if(matrix[i][j]==0){
                   //对应的首行和首列元素记录
                   //注意此时要是matrix[0][0]=0的话，就说明一定是i=0的情况，也就是说首行有0元素的情况
                   matrix[i][0]=0;
                   matrix[0][j]=0;
               }
           }
       }
       //为了matrix[0][0]=0不是因为更新列的原因导致出现的，所以要从后往前遍历
           for(int i=m-1;i>=0;i--){
               for(int j=1;j<n;j++){
                   if(matrix[0][j]==0||matrix[i][0]==0){
                       //对应的行或者列有0，更新
                       matrix[i][j]=0;
                   }
               }
               if(colFlag){
                   //这样只会在最后才更新到matrix[0][0]元素
                   matrix[i][0]=0;
               }
           }
    }
```