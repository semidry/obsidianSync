[LCR 160. 数据流中的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/description/)
本题与主站 295 题相同：

> [!info] 题目
> **中位数** 是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
例如，  
`[2,3,4]` 的中位数是 `3`  
`[2,3]` 的中位数是 `(2 + 3) / 2 = 2.5`  
设计一个支持以下两种操作的数据结构：
>- `void addNum(int num)` - 从数据流中添加一个整数到数据结构中。
>- `double findMedian()` - 返回目前所有元素的中位数。

> [!cite] 示例 1
> **输入：**
`["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]`
`[[],[1],[2],[],[3],[]]`
**输出：**`[null,null,null,1.50000,null,2.00000]`

> [!cite] 示例 2
> **输入：**
`["MedianFinder","addNum","findMedian","addNum","findMedian"]`
`[[],[2],[],[3],[]]`
**输出：**`[null,null,2.00000,null,2.50000]`

> [!help] 提示
> - 最多会对 `addNum、findMedian` 进行 `50000` 次调用。
### 方法一
#优先队列 #堆 
> [!example] 

建立一个 小顶堆 A 和 大顶堆 B ，各保存列表的一半元素，且规定：

A 保存 较大 的一半，长度为  $\frac{N}{2}​$（ N 为偶数）或 $\frac{N+1}{2}$ （ N 为奇数）；
B 保存 较小 的一半，长度为 $\frac{N}{2}$（ N 为偶数）或 $\frac{N-1}{2}$ （ N 为奇数）；
随后，中位数可仅根据 A, B 的堆顶元素计算得到。
![[Pasted image 20240121210841.png]]

**算法流程**：
> 设元素总数为 N = m + n ，其中 m 和 n 分别为 A 和 B 中的元素个数。

`addNum(num)` 函数：

- 当 m = n（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A ；
- 当 $m \ne n$（即 N 为 奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B ；
> 假设插入数字num 遇到情况 1. 。由于 num 可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半。

`findMedian() `函数：

- 当 m = n（ N 为 偶数）：则中位数为 ( A 的堆顶元素 + B 的堆顶元素 )/2。
- 当 $m \ne n$（ N 为 奇数）：则中位数为 A 的堆顶元素。
> [!success] 代码：
```cpp
class MedianFinder {
public:
    priority_queue<int, vector<int>, greater<int>> A; // 小顶堆，保存较大的一半
    priority_queue<int, vector<int>, less<int>> B; // 大顶堆，保存较小的一半
    MedianFinder() { }
    void addNum(int num) {
        if(A.size() != B.size()) {
            A.push(num);
            B.push(A.top());
            A.pop();
        } else {
            B.push(num);
            A.push(B.top());
            B.pop();
        }
    }
    double findMedian() {
        return A.size() != B.size() ? A.top() : (A.top() + B.top()) / 2.0;
    }
};
```
> [!attention] 复杂度
- 时间复杂度：
	- 查找中位数 O(1) ： 获取堆顶元素使用 O(1) 时间；
	- 添加数字 O(logN) ： 堆的插入和弹出操作使用 O(logN) 时间。
- 空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。


