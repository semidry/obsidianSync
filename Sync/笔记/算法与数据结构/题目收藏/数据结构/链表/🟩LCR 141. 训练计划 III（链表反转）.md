[LCR 141. 训练计划 III - 力扣（LeetCode）](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/)
本题与主站 206 题相同：[[🟩206. 反转链表]]
#链表 
> [!info] 题目
> 给定一个头节点为 `head` 的单链表用于记录一系列核心肌群训练编号，请将该系列训练编号 **倒序** 记录于链表并返回。

> [!cite] 示例 1
> 输入：head = `[1,2,3,4,5]`
输出：`[5,4,3,2,1]`

> [!cite] 示例 2
>输入：head = `[1,2]`
输出：`[2,1]`

> [!cite] 示例3
> 输入：head = `[]`
输出：`[]`

> [!help] 提示
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
### 方法一
> [!example] 迭代（双指针）
> 即[[🟩206. 反转链表#^45dbae|206.反转链表的迭代]]

考虑遍历链表，并在访问各节点时修改 `next` 引用指向，算法流程见注释。

> [!tip] Tips
> 1. **暂存后继**：tmp = cur.next；
> 2. **修改指向**：cur.next = pre；
> 3. **更新**：（暂存当前节点，访问下一节点）：pre = cur；cur = tmp；
> 4. **终止条件**：当cur = null时，返回pre。

![[Pasted image 20240118215055.png]]![[Pasted image 20240118215102.png]]
![[Pasted image 20240118215109.png]]
![[Pasted image 20240118215134.png]]
![[Pasted image 20240118215139.png]]
![[Pasted image 20240118215144.png]]![[Pasted image 20240118215152.png]]
![[Pasted image 20240118215157.png]]
![[Pasted image 20240118215203.png]]![[Pasted image 20240118215210.png]]
![[Pasted image 20240118215215.png]]
![[Pasted image 20240118215220.png]]
> [!success] 代码：
```cpp
class Solution {
public:
    ListNode* trainningPlan(ListNode* head) {
        ListNode *cur = head, *pre = nullptr;
        while(cur != nullptr) {
            ListNode* tmp = cur->next; // 暂存后继节点 cur.next
            cur->next = pre;           // 修改 next 引用指向
            pre = cur;                 // pre 暂存 cur
            cur = tmp;                 // cur 访问下一节点
        }
        return pre;
    }
};
```
> [!attention] 复杂度
> - 时间复杂度 O(N) ： 遍历链表使用线性大小时间。
> - 空间复杂度 O(1) ： 变量 pre 和 cur 使用常数大小额外空间。


> [!example] 递归
> 与[[🟩206. 反转链表#^07919e|与206递归方法相同，不赘述]]

> [!success] 代码：
```cpp
class Solution {
public:
    ListNode* trainningPlan(ListNode* head) {
        return recur(head, nullptr);           // 调用递归并返回
    }
private:
    ListNode* recur(ListNode* cur, ListNode* pre) {
        if (cur == nullptr) return pre;        // 终止条件
        ListNode* res = recur(cur->next, cur); // 递归后继节点
        cur->next = pre;                       // 修改节点引用指向
        return res;                            // 返回反转链表的头节点
    }
};
```
> [!attention] 复杂度
> - 时间复杂度：$O (n)$，其中 $n$ 是链表的长度。需要对链表的每个节点进行反转操作。
> - 空间复杂度：$O (n)$，其中 $n$ 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 $n$ 层。