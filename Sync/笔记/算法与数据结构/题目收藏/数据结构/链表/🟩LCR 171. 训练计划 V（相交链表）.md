---
dg-publish: true
---
[LCR 171. 训练计划 V - 力扣（LeetCode）](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/)
本题与主站 160 题相同：[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)
#链表

> [!info] 题目
> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。
> 图示两个链表在节点 `c1` 开始相交**：**
> ![[Pasted image 20240118231433.png]]

> [!cite] 示例 1
> 

> [!cite] 示例 2
> 

> [!help] 提示
> 
### 方法一
> [!example] 
设第一个公共节点为 node ，链表 headA 的节点数量为 a ，链表 headB 的节点数量为 b ，两链表的公共尾部的节点数量为 c ，则有：

- 头节点 headA 到 node 前，共有 a−c 个节点；
- 头节点 headB 到 node 前，共有 b−c 个节点；
![[Pasted image 20240118231746.png]]

考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：

- 指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：a+(b−c)
- 指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：b+(a−c)

如下式所示，此时指针 A , B 重合，并有两种情况：a+(b−c)=b+(a−c)
1. 若两链表 有 公共尾部 (即 c>0 ) ：指针 A , B 同时指向「第一个公共节点」node 。
2. 若两链表 无 公共尾部 (即 c=0 ) ：指针 A , B 同时指向 null 。

因此返回 A 即可。
![[Pasted image 20240118231853.png]]
![[Pasted image 20240118231918.png]]
![[Pasted image 20240118231927.png]]
![[Pasted image 20240118231934.png]]
> [!success] 代码：
```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;
            B = B != nullptr ? B->next : headA;
        }
        return A;
    }
};
```
> [!attention] 复杂度
> **时间复杂度** O(a+b) ： 最差情况下（即 ∣a−b∣=1 , c=0 ），此时需遍历 a+b 个节点。
**空间复杂度** O(1) ： 节点指针 A , B 使用常数大小的额外空间。



