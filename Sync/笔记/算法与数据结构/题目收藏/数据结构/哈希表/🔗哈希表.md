---
dg-publish: true
---
#目录 

## 题目
### 哈希表
[哈希表 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/hash-table-plus/kar61/)
>  [[🟩349. 两个数组的交集]]
>  [[🟩1. 两数之和]]
>  [[🟩205. 同构字符串]]
>  [[🟧424. 替换后的最长重复字符]]
>  [[🟧1004. 最大连续1的个数 III]]
>  [[🟧159. 至多包含两个不同字符的最长子串]]
>  [[🟧36. 有效的数独]]
>  [[🟧652. 寻找重复的子树]]
>  [[🟧311. 稀疏矩阵的乘法]]
>  [[🟧LCR 154. 复杂链表的复制]]

![[Pasted image 20240118174952.png]]
## 设计哈希表
### 哈希表简介
哈希表是一种使用哈希函数组织数据的数据结构，它支持快速插入和搜索。
### 哈希表的原理
哈希表（又称散列表）的原理为：借助哈希函数，将键映射到存储桶地址。更确切地说，
- 首先开辟一定长度的，具有连续物理地址的桶数组；
- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；
- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

#### 示例

![[Pasted image 20240114220650.png]]
在示例中，我们使用 y = x ％ 5 作为哈希函数，来完成插入和搜索策略。

1. 插入：我们通过哈希函数解析键，将它们映射到相应的桶中。

	- 例如，根据哈希函数，1987 将分配给桶 2，而 24 分配给桶 4。
2. 搜索：我们通过哈希函数解析键，得到桶地址，然后在该存储桶中搜索。

	- 如果我们搜索 1987，我们将使用哈希函数将 1987 映射到 2。因此我们在桶 2 中搜索，我们在那个桶中成功找到了 1987。

	- 例如，如果我们搜索 23，将映射 23 到 3，并在桶 3 中搜索。我们发现 23 不在桶 3 中，这意味着 23 不在哈希表中。

注意到键 1987 和 2 被映射到了同一个桶中，我们称之为哈希冲突，哈希冲突与哈希函数有关，但又难以避免。有关处理哈希冲突的办法，我们将在下一节详细介绍。

#### 负载因子
负载因子又叫装填因子，是哈希表的一个重要参数，它反映了哈希表的装满程度。

在上面的例子中，我们发现有的桶处于空闲状态，而有的桶产生了哈希冲突，如何解决这个问题呢？

不难想到，哈希函数是导致冲突的原因之一，更进一步，如果我们增加桶的数量，再采用合适的哈希函数，可使发生冲突的可能性大大减小。

然而，桶的个数太多则会造成大量的空间浪费。比如一个公司的电话号码共有 10 个，每个电话号码是 00000000 到 99999999 内的任意八位数字，如果我们想到一种方案，将每个可能的电话号码作为一个桶，使得电话号码与桶一一对应，则一共需要创建 $10^8$ 个桶。
![[Pasted image 20240114220700.png]]


实际利用桶的个数与桶的总数的比值，称为负载因子。在这个实例中，负载因子太小甚至接近于 0，这样的方案显然是不现实的。

比较合理的负载因子是 0.7，如果数据量是 7，则会创建 10 个桶，以此类推。随着插入的数据量的增加，计算机会逐渐增加桶的个数，并选择合适的哈希函数，使得数据经过映射之后能均匀地分布在桶中。
### 设计哈希表时的问题
理解了什么是哈希表之后，我们再来讨论一下设计哈希表时应当注意的几个问题。

#### 哈希函数
哈希函数是哈希表中最重要的组件，用于将键映射到特定的桶。在上一篇文章中的示例中，我们使用 y = x % 5 作为散列函数，其中 x 是键值，y 是映射之后对应的桶的索引。

一个好的哈希函数，应当具备以下几个特点：

- 哈希函数的键与桶的对应关系具有确定性。也就是说，对于 key 所映射的桶地址，只由 key 键本身决定，而不由其他因素决定；
- 哈希函数不应太过复杂。太过于复杂的哈希函数将导致计算桶地址不能快速完成，从而无法快速定位桶；
- 映射结果的分布应具有均匀性。对于特定的桶空间，我们应尽量保证数据经过哈希函数映射之后，能够均匀地分布在桶的整个地址空间中。

下面是一些哈希函数的示例：
![[Pasted image 20240114221031.png]]


理想情况下，完美的哈希函数将是键和桶之间的一对一映射。然而，在大多数情况下，完美的哈希函数并不多见。一般来讲，结果分布越随机，越均匀的哈希函数，它的性能越好。一方面，如果分布过于集中在某些桶中，会加剧这些桶发生冲突的概率；另一方面，剩余的桶由于没有得到有效利用导致空间利用率较低。

#### 冲突解决
一般情况下，哈希函数会起到压缩键的地址空间的作用，设键的地址空间为 S，桶的地址空间为 T，则有 $S≫T$。
![[Pasted image 20240114221039.png]]


因此，经过映射之后，不同的数据会不可避免地分配到同一个桶中，这时便产生了冲突。例如，在我们之前的哈希函数 y = x ％ 5 中，1987 和 2 都分配给了桶 2，这是一个冲突。

为了避免哈希冲突，我们简要介绍几种解决冲突的办法。

##### 线性试探法

线性试探法属于开放定址法的一种，除此之外，开放定址法还包括二次探测法、双重哈希法等。

所谓线性试探法，就是当插入键 key 时，如果发现桶单元` bucket[hash (key)] `已经被占用，则向下线性寻找，直到找到可以使用的空桶。具体说来，经过第 i 次试探之后，桶单元应为：

$$Bucket[(hash (key)+i)\space mod \space M],  i=1,2,3…$$

例如对于键的集合为 {8, 9, 21, 17, 34, 21, 4}，哈希函数为 y = x % 8，集合中的前三个数 8, 9, 21，它们分别映射到 0, 1, 5 号桶中。

而对于第四个数 17，它本应映射到 1 号桶中，由于 1 号桶中已经保存了 9，因此将 17 保存在下一个空桶—— 2 号桶中。同理，34 余数为 2，会保存在 3 号桶中。
![[Pasted image 20240114221050.png]]


当查找某个键时，首先会通过哈希函数计算出桶的地址，然后比较该桶中保存的值是否为该键，如果不是，则继续向下寻找。如果查找到末尾，则会从头开始查找。

而删除某个键时，为了避免查找过程中出现信息丢失，会将删除位置标记为 deleted，这样当进行线性查找时，遇到 deleted 会继续向下查找而不会中断。
![[Pasted image 20240114221056.png]]


##### 链地址法

解决冲突的另一种办法是将桶内产生冲突的键串联成一个链表。仍然以前一个方法中的冲突为例，实现方式如下图所示。
![[Pasted image 20240114221102.png]]


与线性探测法类似，发生冲突时，由于都需要进行线性查找，因此会导致查找的成本增加。

##### 再哈希法

再哈希法比较典型的应用是双重哈希法，即发生冲突时，通过使用另一个哈希函数来避免冲突。不难想到，另一个哈希函数在构造时，需要具备一些约束条件才能避免再次冲突。

然而，双重哈希法同样存在一些问题：

- 与线性试探法相比，双重哈希法会消耗较多的时间。
- 在双重哈希法中，删除会使问题变复杂，如果逻辑删除数量太多，则应重新构造哈希表。

##### 公共溢出区法

顾名思义，公共溢出区法就是建立另一个哈希表 dict_overflow 作为公共溢出区，当发成冲突时则将该键保存在该哈希表中。
![[Pasted image 20240114221108.png]]


如图所示，若查找的键发生冲突，则在公共溢出区进行线性查找。

### 解决方案
这里分别给出设计哈希集合和哈希映射的解决方案。为了解决哈希冲突，我们使用二维数组来实现哈希集合，数组中的每个元素都可以看作一个桶，而在每个桶中又包含一个一维数组，以便保存产生冲突的键。
![[Pasted image 20240115093810.png]]


#### 哈希集合
```C++
#define MAX_LEN 100000          // 初始化桶的数量

Class MyHashSet {
Private:
    vector<int> set[MAX_LEN];   // 使用数组实现哈希集合
    
    /** 返回对应的桶的索引 */
    Int getIndex (int key) {
        Return key % MAX_LEN;
    }
    
    /** 在特定的桶中搜索键，如果该键不存在则返回 -1 */
    Int getPos (int key, int index) {
        // 每个桶中包含一个列表，遍历所有桶中的元素来寻找特定的键
        For (int i = 0; i < set[index]. Size (); ++i) {
            If (set[index][i] == key) {
                Return i;
            }
        }
        Return -1;
    }
Public:
    
    MyHashSet () {
        
    }
    
    Void add (int key) {
        Int index = getIndex (key);
        Int pos = getPos (key, index);
        If (pos < 0) {
            // 如果键不存在，则添加
            Set[index]. Push_back (key);
        }
    }
    
    Void remove (int key) {
        Int index = getIndex (key);
        Int pos = getPos (key, index);
        If (pos >= 0) {
            // 如果键存在，则删除
            Set[index]. Erase (set[index]. Begin () + pos);
        }
    }
    
    Bool contains (int key) {
        Int index = getIndex (key);
        Int pos = getPos (key, index);
        Return pos >= 0;
    }
};
```

#### 哈希映射
```C++
#define MAX_LEN 100000            // 初始化桶的数量

Class MyHashMap {
Private:
    vector<pair<int, int>> map[MAX_LEN];       // 使用数组实现哈希集合
    
    /** 返回指定桶的索引 */
    Int getIndex (int key) {
        Return key % MAX_LEN;
    }
    
    /** 在桶中搜索键，如果不存在则返回 -1 */
    Int getPos (int key, int index) {
        // 每个桶包含一个数组，遍历桶中的所有元素来查找指定的 key
        For (int i = 0; i < map[index]. Size (); ++i) {
            If (map[index][i]. First == key) {
                Return i;
            }
        }
        Return -1;
    }
    
Public:
    MyHashMap () {
        
    }
    
    /** value 始终为正 */
    Void put (int key, int value) {
        Int index = getIndex (key);
        Int pos = getPos (key, index);
        If (pos < 0) {
            Map[index]. Push_back (make_pair (key, value));
        } else {
            Map[index][pos]. Second = value;
        }
    }
    
    /** 如果存在映射关系，则返回 value，否则返回 -1 */
    Int get (int key) {
        Int index = getIndex (key);
        Int pos = getPos (key, index);
        If (pos < 0) {
            Return -1;
        } else {
            Return map[index][pos]. Second;
        }
    }
    
    /** 如果存在 key 的映射，则删除该映射关系 */
    Void remove (int key) {
        Int index = getIndex (key);
        Int pos = getPos (key, index);
        If (pos >= 0) {
            Map[index]. Erase (map[index]. Begin () + pos);
        }
    }
};
```
#### 进一步探索
我们来看看 “删除” 操作，找到元素的位置之后，我们需要从数组中 “删除” 元素。

这是由数组本身的特点决定的。在探索卡片数组的操作中，我们对数组的 “删除” 操作进行了解释，即删除第 i 个元素，需要将后面的 n - i 个元素向前移动一个位置。其中，n 为数组的长度。

![[52b92b3ae1e369f23304ec1d46c1b25bc2077e8989c80be9fe257e8213b438f0-2 1.gif]]

考虑 i 取不同值的情况：

- 删除末尾元素，移动 0 次；
- 删除开头元素，移动 n - 1 次。

平均而言，我们将要移动的次数为：
$$
\frac{((n-1)+(n-2)+……+1+0)}{n}=\frac{n-1}{2}
$$

因此，找到待删除元素后，从数组中删除元素的时间复杂度将为 $O (n)$。

以下两种方案可以将时间复杂度从 $O (n)$ 降低到 $O (1)$。

1. 交换

	我们可以使用一种巧妙的策略。首先，用存储桶中的最后一个元素交换要移除的元素。然后删除最后一个元素。通过这种方法，我们成功地在 $O (1)$ 的时间复杂度中去除了元素。

2. 链表

	实现此目标的另一种方法是使用链表而不是数组列表。通过这种方式，我们可以在不修改数组中元素顺序的情况下删除元素。该策略时间复杂度为 $O (1)$。
	然而，以上两种策略只改进了找到元素之后进行删除的时间复杂度，而对于整个删除操作，由于先要进行线性查找，所以时间复杂度仍为 $O (n)$，N 为桶的大小。
	要进一步改进此问题，我们可以使用平衡二叉搜索树作为桶，当进行删除操作时，则可以使用二分查找来快速定位被删除元素，使得删除操作的时间复杂度由 $O (n)$ 减小为 $O (log n)$，N 为桶的大小。

### 复杂度分析-哈希表
在本文中，我们将讨论哈希表的性能。

#### 复杂度分析
对于哈希表，插入和搜索的平均时间复杂度为 $O(1)$，空间复杂度为 $O(n)$。下面将进一步分析。

我们知道哈希表在设计的过程中总是要考虑冲突问题，这是因为不发生冲突几乎是不可能的。

例如我们经常谈到的——“在 50 人中，至少有 2 人同一天生日的概率是 97%”，这就意味着，如果我们将 365 天看作 365 个桶，每个桶保存一个人的生日，那么发生冲突概率则高达 97%，而此时的装填因子仅为13.7%

也就是说，为了使插入和查询的时间复杂度达到 $O(1)$，我们可以选择牺牲空间复杂度，增加桶的个数，使其不发生冲突。然而经过分析，我们发现即使装填因子很低的情况下，冲突仍然难以避免。因此就有了前面文章中关于冲突解决的各种办法，本质上是为了达到时间与空间的平衡。

既然如此，插入和搜索的时间复杂度就不会总是 $O(1)$，它将取决于桶内部存储发生冲突的键的方式。

- 如果桶内使用 链表 或者 数组，则最坏情况下，插入和搜索的时间复杂度为 $O(n)$；
- 如果桶内使用 高度平衡的二叉树 来保存键，则最坏情况下，插入和搜索的时间复杂度为 $O(log n)$。

其中，n 为桶的大小。且无论使用以上那种方式，平均时间复杂度 均为 $O(1)$。

![[Pasted image 20240115095247.png]]

对于空间复杂度，如果总共有 M 个键，那么至少需要分配 M 个桶，在实际的编程语言中，有各自的动态扩容机制，但总的来说，桶的个数与键呈线性关系，空间复杂度为 $O(M)$。

## 哈希集合-实际应用
### 哈希集合的操作
哈希集合是集合的实现方式之一，它是一种存储不重复值的数据结构。
```C++
#include <unordered_set>               

Int main () {
    // 1. 初始化哈希集
    unordered_set<int> hashset;   
    // 2. 新增键
    Hashset.Insert (3);
    Hashset.Insert (2);
    Hashset.Insert (1);
    // 3. 删除键
    Hashset.Erase (2);
    // 4. 查询键是否包含在哈希集合中
    If (hashset.Count (2) <= 0) {
        Cout << "键 2 不在哈希集合中" << endl;
    }
    // 5. 哈希集合的大小
    Cout << "哈希集合的大小为: " << hashset.Size () << endl; 
    // 6. 遍历哈希集合
    For (auto it = hashset.Begin (); it != hashset.End (); ++it) {
        Cout << (*it) << " ";
    }
    Cout << "在哈希集合中" << endl;
    // 7. 清空哈希集合
    Hashset.Clear ();
    // 8. 查看哈希集合是否为空
    If (hashset.Empty ()) {
        Cout << "哈希集合为空！" << endl;
    }
}
```
### 使用哈希集合查重
我们知道，由于哈希集合中的元素是不重复的，因此可以使用哈希集合来判断是否包含重复元素。

#### 实例
让我们来看一个例子：

> 给定一个整数数组，判断该数组中是否包含重复元素。

这是一个典型的问题，用来判断某个数据结构中是否包含重复元素，或者对某个数据结构进行去重的操作。

解决这类问题的简单思路是遍历该数据结构，并将值插入到哈希集合中。如果该值已经存在于哈希集合中，表明发生了重复。

下面是伪代码模板：

```C++
/*
 * 使用哈希集合寻找重复元素的模板
 */
bool findDuplicates (vector<Type>& keys) {
    // 将 type 替换为 keys 的实际类型
    unordered_set<Type> hashset;
    For (Type key : keys) {
        If (hashset.Count (key) > 0) {
            Return true;
        }
        Hashset.Insert (key);
    }
    Return false;
}
```

## 实际应用-哈希映射
### 哈希表的操作
哈希表 是用来存储 (key, value) 键值对的一种实现。

```C++
#include <unordered_map>                

int main() {
    // 1. 初始化哈希表
    unordered_map<int, int> hashmap;
    // 2. 插入一个新的（键，值）对
    hashmap.insert(make_pair(0, 0));
    hashmap.insert(make_pair(2, 3));
    // 3. 插入一个新的（键，值）对，或者更新值
    hashmap[1] = 1;
    hashmap[1] = 2;
    // 4. 获得特定键对应的值
    cout << "The value of key 1 is: " << hashmap[1] << endl;
    // 5. 删除键
    hashmap.erase(2);
    // 6. 检查键是否存在于哈希表中
    if (hashmap.count(2) <= 0) {
        cout << "键 2 不在哈希表中" << endl;
    }
    // 7. 哈希表的大小
    cout << "哈希表的大小为: " << hashmap.size() << endl; 
    // 8. 遍历哈希表
    for (auto it = hashmap.begin(); it != hashmap.end(); ++it) {
        cout << "(" << it->first << "," << it->second << ") ";
    }
    cout << "在哈希表中" << endl;
    // 9. 清空哈希表
    hashmap.clear();
    // 10. 检查哈希表是否为空
    if (hashmap.empty()) {
        cout << "哈希表为空！" << endl;
    }
}
```
### 情景 Ⅰ - 构造哈希表
什么情况下会想到使用哈希表呢？当我们需要 同时得到关联信息 时，可以使用哈希表建立 key 与 value 的映射关系。

例如对于一个数组 A，我们想知道每个元素最后一次出现的位置，这时，元素和最后一次出现的位置信息相关联，则可以使用 {A[i]:A[i] 最后出现的下标} 这样的映射关系来构造哈希表。

学会构造哈希表，将是我们熟练应用哈希表的一个前提。构造哈希表前，我们需要仔细分析题目中相关因素之间的关系，然后为键和值选择合适的数据类型。

示例
这是一个经典问题：

> 两数之和：给定一个整数数组，返回两个元素的 索引，使这两个元素之和为 target。

如果我们枚举每一个下标 i 和 j，如果他们指向的元素等于 target，这时便找到了答案，但是时间复杂度将达到 $O(n^2)$

使用哈希表可以将时间复杂度降为 $O(N)$。首先，返回的是元素的 下标，所以可以考虑使用 `{元素:下标}` 的结构构造哈希表；其次，遍历数组的过程中，如果当前元素为` x`， `target - x` 在之前已经遍历过，则表明` [下标(x), 下标(target - x)] `就是答案，否则，将 `x:下标(x)` 添加到哈希表中。

![[Pasted image 20240115164838.png]]

如图，当前 x 位于下标 3 且 x = 15，发现 target - x = 7 在哈希表中，所以直接返回 `[1, 3]`。

更多
注意到上面的例子中，我们使用了 `{键:下标}` 的形式构建哈希表，除此之外，根据值类别的不同，常用的构造方式还有以下几种：

- `{键:频次}`：使用频率最高，将元素出现的次数作为值；
- `{键:数组}`：如果一个键对应的信息是一组元素，可使用数组或链表存储。
- `{键:平面坐标}`：某些矩阵类习题可能会存储坐标；
- `{键:其他}`：一般出现在模拟题中，根据实际需要设计哈希表。

因此，当遇到某个问题可使用哈希表解决时，可以从以上几种构造方法中进行筛选。

### 情景 Ⅱ - 哈希表与滑动窗口
本文将介绍滑动窗口技巧，以及哈希表在滑动窗口中的应用。

#### 什么是滑动窗口
顾名思义，滑动窗口就是将数组或字符串中的一个分段，形象地看作一个“窗口”，通过更改“窗口”的左右边界，实现窗口的移动、缩放等操作。

![[Pasted image 20240115231157.png]]

如图所示，窗口的左右边界使用 `i`,` j` 实现，当两个指针同时向右移动，则为窗口的“滑动”操作；而当其中一个指针不动，另一个指针向右移动时，窗口会扩大或缩小。

需要注意的是，一般情况下，在实际题目中指针只会沿 一个方向 移动。

使用哈希表
对于基本情况，滑动窗口使用双指针即可实现，但是有时会出现一些问题，假如如窗口中的元素为 "`(aaaaaabc)`"，左右边界指针分别为 i 和 j，如果我们想要将窗口变为 "`(abc)`"，可以选择将左边界指针 i 向右移动 5 步。

以上情况会造成时间的浪费，假如建立元素 a 为键，下标为值的哈希表` {"a":5}`，那么元素 a 只需 1 步即可“跳跃”到下标 5 的位置。

优化运行时间，是滑动窗口问题中使用哈希表的一个目的。除此之外，哈希表还被用来统计窗口中的元素个数，以判断当前窗口的状态是否满足条件。以下是滑动窗口类题目的总结：

![[Pasted image 20240115231210.png]]

## 实际应用-设计键
### 设计键
在前面的问题中，我们主要考虑了根据值的不同形式构造哈希表，而键的设计相对简单。然而在某些题目中，我们可能已经想到了哈希表的解法，但受限于 无法设计出合适的键，本章将对键的设计做出总结。

#### 示例
我们来看一个例子：

> 给定一组字符串，将字母异位词组合在一起。

字母异位词指字母相同，但排列不同的字符串，比如 "`ate`" 与 "`eat`" 是一组字母异位词。如果单纯地把每个字符串作为键，显然没有起到任何作用。

#### 解决方案
经过分析发现，同一组字母异位词中，如果按照字典序排列，得到的字符串相同，且长度相等。这时我们自然想到以 按照字典序排列后的字符串 作为键，这样就能合理区分出字母异位词了。例如对于 "`ate`" 和 "`eat`" 构造的哈希表为 `{"aet":["ate", "eat"]}`。


### 设计键-总结
以下是一些关于设计键的方法总结，我们鼓励你根据以下思路及做题经验，做出自己的总结。

1. 当字符串 / 数组中每个元素的顺序不重要时，可以使用 排序后的字符串 / 数组 作为键。
![[Pasted image 20240118174829.png]]

2. 如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用偏移量作为键。
![[Pasted image 20240118174837.png]]

3. 在树的题目中，可以直接使用 TreeNode 作为键。但在大多数情况下，可以将 子树的序列化结果 作为键。
![[Pasted image 20240118174845.png]]

4. 在矩阵中，你可能会使用 行索引 或 列索引 作为键。

5. 如果需要将矩阵分块，可以将行索引和列索引进行组合以标识该元素属于哪个 块。
![[Pasted image 20240118174900.png]]


6. 有时，在矩阵中，你可能会希望将对角线的元素组合在一起。
![[Pasted image 20240118174907.png]]
## 小结
![[Pasted image 20240118174952.png]]
我们可能需要：
- 使用多个哈希表
- 将哈希表与其他数据结构相结合
- 将哈希表与其他算法结合起来