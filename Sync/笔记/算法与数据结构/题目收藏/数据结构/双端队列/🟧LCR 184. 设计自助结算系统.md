---
dg-publish: true
---
[LCR 184. 设计自助结算系统 - 力扣（LeetCode）](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/)
#双端队列 
> [!info] 题目
> 请设计一个自助结账系统，该系统需要通过一个队列来模拟顾客通过购物车的结算过程，需要实现的功能有：
>- `get_max()`：获取结算商品中的最高价格，如果队列为空，则返回 -1
>- `add(value)`：将价格为 `value` 的商品加入待结算商品队列的尾部
>- `remove()`：移除第一个待结算的商品价格，如果队列为空，则返回 -1

注意，为保证该系统运转高效性，以上函数的均摊时间复杂度均为 O(1)

> [!cite] 示例 1
> 输入: 
`["Checkout","add","add","get_max","remove","get_max"]`
`[[],[4],[7],[],[],[]]`
输出: `[null,null,null,7,4,7]`

> [!cite] 示例 2
> 输入: 
`["Checkout","remove","get_max"]`
`[[],[],[]]`
输出: `[null,-1,-1]`

> [!help] 提示
> - `1 <= get_max, add, remove 的总操作数 <= 10000`
>- `1 <= value <= 10^5`
### 方法一
> [!example] 

考虑利用 数据结构 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个递减列表来保存队列 所有递减的元素 ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值 O(1) 时间复杂度。
![[Pasted image 20240121205646.png]]
为了实现此递减列表，需要使用 双向队列 ，假设队列已经有若干元素：
1. 当执行入队 add() 时： 若入队一个比队列某些元素更大的数字 x ，则为了保持此列表递减，需要将双向队列 尾部所有小于 x 的元素 弹出。
2. 当执行出队 remove() 时： 若出队的元素是最大元素，则 双向队列 需要同时 将首元素出队 ，以保持队列和双向队列的元素一致性。
> 使用双向队列原因：维护递减列表需要元素队首弹出、队尾插入、队尾弹出操作皆为 �(1)O(1) 时间复杂度。

> [!success] 代码：
```cpp
class Checkout {
    queue<int> que;
    deque<int> deq;
public:
    Checkout() { }
    int get_max() {
        return deq.empty() ? -1 : deq.front();
    }
    void add(int value) {
        que.push(value);
        while(!deq.empty() && deq.back() < value)
            deq.pop_back();
        deq.push_back(value);
    }
    int remove() {
        if(que.empty()) return -1;
        int val = que.front();
        if(val == deq.front())
            deq.pop_front();
        que.pop();
        return val;
    }
};
```
> [!attention] 复杂度
> - **时间复杂度**：$O(1)$
> - **空间复杂度**：$O(N)$

相关：
[[🟥LCR 183. 望远镜中最高的海拔]]