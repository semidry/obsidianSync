---
dg-publish: true
---
![[Pasted image 20240103123055.png]]
![[Pasted image 20240103123101.png]]
首先，我们来谈谈常用操作的时间复杂度，按数据结构/算法划分。然后，我们将讨论给定输入大小的合理复杂性。

---


# 数组（动态数组列表）
规定`n=arr.Length` ，
- 在结尾添加或删除元素：O(1)
- 从任意索引中添加或删除元素：O(n)
- 访问或修改任意索引处的元素：O(1)
- 检查元素是否存在：O(n)
- 双指针：O(nk),k是每次迭代所做的工作，包括滑动窗口
- 构建前缀和：O(n)
- 求给定前缀和的子数组的和：O(1)
---
# 字符串（不可变）
规定`n=s.Length` ,
- 添加或删除字符：O(n)
- 任意索引处的访问元素：O(1)
- 两个字符串之间的连接：O(n+m),m是另一个字符串的长度
- 创建子字符串：0(m),m是子字符串的长度
- 双指针：O(n.k),k是每次迭代所做的工作，包括滑动窗口
- 通过连接数组、stringbuilder 等构建字符串：O(n)
---
# 链表
给定n作为链表中的节点数，
- 给定指针位置的后面添加或删除元素：O(1)
- 如果是双向链表，给定指针位置添加或删除元素：O(1)
- 在没有指针的任意位置添加或删除元素：O(n)
- 无指针任意位置的访问元素：O(n)
- 检查元素是否存在：O(n)
- 在位置i和j之间反转：O(j-i)
- 使用快慢指针或哈希映射完成一次遍历：O(n)
---
# 哈希表字典
给定`n=dic.Length` ，
- 添加或删除键值对：O(1)
- 检查key是否存在：O(1)
- 检查值是否存在：O(n)
- 访问或修改与key相关的值：O(1)
- 遍历所有键值：O(n)
> 注意：O(1)操作相对于n是常数实际上，哈希算法可能代价很高。例如，如果你的键是字符串，那么它将花费O(m),其中m是字符串的长度。这些操作只需要相对于哈希映射大小的常数时间。
---
# 集合
给定`n=set.Length` ,
- 添加或删除元素：O(1)
- 检测元素是否存在：O(1)
> 上面的说明也适用于这里。
---
# 栈
栈操作依赖于它们的实现。栈只需要支持弹出和推入。如果使用动态数组实现：
给定`n=stack .length` ,
- 推入元素：O(1)
- 弹出元素：O(1)
- 查看（查看栈顶元素）：O(1)
- 访问或修改任意索引处的元素：O(1)
- 检测元素是否存在：O(n)
---
# 队列
队列操作依赖于它们的实现。队列只需要支持出队列和入队列。如果使用双链表实现：给定`n=queve .length` ,
- 入队的元素：O(1)
- 出队的元素：O(1)
- 查看（查看队列前面的元素）：O(1)
- 访问或修改任意索引处的元素：O(n)
- 检查元素是否存在：O(n)
> 注意：大多数编程语言实现队列的方式比简单的双链表更复杂。根据实现的不同，通过索引访问元素可能比O(n)快，但有一个重要的常量除数。
---
# 二叉树问题(DFS/BFS)
给定n作为树的节点数，
大多数算法的时间复杂度为O(nk),k是在每个节点上做的操作数，通常是O(1)。这只是一个普遍规律，并非总是如此。我们在这里假设BFS是用高效队列实现的。

---
# 二叉搜索树
给定n作为树中的节点数，
- 添加或删除元素：最坏的情况下O(n),平均情况O(logn)
- 检查元素是否存在：最坏的情况下O(n),平均情况O(logn)
平均情况是当树很平衡时-每个深度都接近满。最坏的情况是树只是一条直线。
---


# 堆优先队列
给定`n=heap.Length` 并讨论最小堆，
- 添加一个元素：O(logn)
- 删除最小的元素：O(logn)
- 找到最小的元素：O(1)
- 查看元素是否存在：O(n)
---


# 二分查找
在最坏的情况下，二分查找的时间复杂度为O(logn),其中n是初始搜索空间的大小。

---


# 其他
- 排序：O(nlogn),其中n是要排序的数据的大小
- 图上的DFS和BFS:O(n.k+e),其中n是节点数，e是边数，前提是每个节点处理花费都是O(1),不需要重复遍历。
- DFS和BFS空间复杂度：通常为O(n),但如果它在图形中，则可能为O(n+e)来存储图形
- 动态规划时间复杂度：O(nk),其中n是状态数，k是每个状态所需要的操作数
- 动态规划空间复杂度：O(n),其中n是状态数
---
![[Pasted image 20240103133757.png]]
