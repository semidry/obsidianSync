---
dg-publish: true
---
**n <= 10**
基数大于2的阶乘或指数，例如$O(n^2\cdot n!)$或$O(4^n)$
考虑回溯或任何蛮力式递归算法，通常**任何**正确找到答案的算法都足够快。

---
**10 < n <= 20**
$O(2^n)$
通常意味着给定一个元素集合，您正在考虑所有子集/子序列 - 对于每个元素，有两种选择：接受或不接受。
同样，这个界限非常小，所以大多数正确的算法可能足够快。考虑回溯和递归。

---
**20 < n <= 100**
$O(n^3)$

---
**100 < n <= 1,000**
$O(n^2)$

---
**1,000 < n < 100,000**
$O(n\cdot log_2n)$ , $O(n)$

- 哈希映射
- 类似于滑动窗口的两指针实现
- 单调堆栈
- 二分搜索
- 堆
- 以上任何一项的组合

---
**100,000 < n < 1,000,000**
$O(n)$ , $O(n\cdot log_2n)$

---
**1,000,000 < n**
$O(log_2n)$ , $O(1)$
必须要么在每次迭代时显着减少搜索空间（通常是二分搜索），要么使用巧妙的技巧在恒定时间内查找信息（例如使用数学或巧妙地使用哈希映射）。
> 其他时间复杂度也是可能的，例如$O(\sqrt{n})$，但这种情况非常罕见，通常只会出现在非常高级的问题中。