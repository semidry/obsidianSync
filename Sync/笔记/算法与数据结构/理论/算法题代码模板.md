---
dg-publish: true
---
### 1. åŒæŒ‡é’ˆ: åªæœ‰ä¸€ä¸ªè¾“å…¥, ä»ä¸¤ç«¯å¼€å§‹éå†
```cpp
int fn(vector<int>& arr) {
    int left = 0;
    int right = int(arr.size()) - 1;
    int ans = 0;

    while (left < right) {
        // ä¸€äº›æ ¹æ® letf å’Œ right ç›¸å…³çš„ä»£ç è¡¥å……
        if (CONDITION) {
            left++;
        } else {
            right--;
        }
    }

    return ans;
}
```
---
### 2. åŒæŒ‡é’ˆ: æœ‰ä¸¤ä¸ªè¾“å…¥, ä¸¤ä¸ªéƒ½éœ€è¦éå†å®Œ

```cpp
int fn(vector<int>& arr1, vector<int>& arr2) {
    int i = 0, j = 0, ans = 0;

    while (i < arr1.size() && j < arr2.size()) {
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        if (CONDITION) {
            i++;
        } else {
            j++;
        }
    }

    while (i < arr1.size()) {
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        i++;
    }

    while (j < arr2.size()) {
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        j++;
    }

    return ans;
}
```
---
### 3. æ»‘åŠ¨çª—å£

[[æ»‘åŠ¨çª—å£]]

```cpp
int fn(vector<int>& arr) {
    int left = 0, ans = 0, curr = 0;

    for (int right = 0; right < arr.size(); right++) {
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç æ¥å°† arr[right] æ·»åŠ åˆ° curr

        while (WINDOW_CONDITION_BROKEN) {
            // ä» curr ä¸­åˆ é™¤ arr[left]
            left++;
        }

        // æ›´æ–° ans
    }

    return ans;
}
```
---
### 4. æ„å»ºå‰ç¼€å’Œ

```cpp
vector<int> fn(vector<int>& arr) {
    vector<int> prefix(arr.size());
    prefix[0] = arr[0];

    for (int i = 1; i < arr.size(); i++) {
        prefix[i] = prefix[i - 1] + arr[i];
    }

    return prefix;
}
```
---
### 5. é«˜æ•ˆçš„å­—ç¬¦ä¸²æ„å»º

```cpp
string fn(vector<char>& arr) {
	return string(arr.begin(), arr.end()) 
}
```
---
### 6. é“¾è¡¨: å¿«æ…¢æŒ‡é’ˆ

```cpp
int fn(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    int ans = 0;

    while (fast != nullptr && fast->next != nullptr) {
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        slow = slow->next;
        fast = fast->next->next;
    }

    return ans;
}
```
---
### 7. åè½¬é“¾è¡¨
[[ğŸŸ©206. åè½¬é“¾è¡¨]]
> æƒ³è±¡ä¸€ä¸ªæ°”çƒä»å‰å¾€åä¼ ï¼Œæ¯ä¸ªäººåŸæœ¬æ˜¯å‘å³æ’é˜Ÿï¼Œæ‰€æœ‰æ‹¿è¿‡æ°”çƒçš„äººéƒ½æœå‘å·¦ã€‚
> æ¯ä¸ªé˜Ÿä¸­å…ƒç´ éƒ½æœ‰ç›¸åŒçš„æ“ä½œï¼Œå½“å‰çš„ä¸‹ä¸€æ­¥å…ˆç¼“å­˜èµ·æ¥ï¼Œç„¶åæŠŠå½“å‰çš„ä¸‹ä¸€æ­¥æŒ‡å‘å‰ç½®æŒ‡é’ˆï¼Œå‰ç½®æŒ‡é’ˆåç§»åˆ°å½“å‰æŒ‡é’ˆæŒ‡å‘å…ƒç´ ï¼Œå½“å‰å…ƒç´ åç§»å°†ç¬¬ä¸€æ­¥ç¼“å­˜çš„å½“å‰ä¸‹ä¸€æ­¥èµ‹å€¼ç»™å½“å‰ï¼Œå®Œæˆå½“å‰æŒ‡é’ˆçš„åç§»ã€‚
> 
> å‰ç½®æŒ‡é’ˆæŒ‡å‘ç©ºï¼Œ
> å½“å‰æŒ‡é’ˆæŒ‡å‘å¤´ï¼Œ
> å½“å‰æŒ‡é’ˆä¸ä¸ºç©º
> å¾ªç¯ä½“å†…
> åˆ›å»ºä¸‹ä¸€æ­¥æŒ‡é’ˆ
> æŒ‡å‘å½“å‰åä¸€æ­¥
> 
> å½“å‰è½¬æŒ‡å‰æŒ‡é’ˆ
> å‰æŒ‡é’ˆç§»æ­¥å½“å‰
> å½“å‰ç§»æ­¥åä¸€æ­¥
> 
> å¾ªç¯ä½“ç»“æŸ
> è¿”å›å‰ç½®æŒ‡é’ˆã€‚

```cpp
ListNode* fn(ListNode* head) {
    ListNode* curr = head;
    ListNode* prev = nullptr;
    while (curr != nullptr) {
	    //ä¿å­˜é“¾è¡¨åŸæœ‰é¡ºåºçš„ä¸‹ä¸€ä¸ªç»“ç‚¹
        ListNode* nextNode = curr->next;
        //ä»¤ç»“ç‚¹æŒ‡å‘ä¸Šä¸€ä¸ªç»“ç‚¹
        curr->next = prev;
        //æ›´æ–°ç»“ç‚¹å¯¹
        prev = curr;
        curr = nextNode;
    }

    return prev;
}
```
---
### 8. æ‰¾åˆ°ç¬¦åˆç¡®åˆ‡æ¡ä»¶çš„å­æ•°ç»„æ•°

[[ğŸŸ§560. å’Œä¸º K çš„å­æ•°ç»„]]
```cpp
int fn(vector<int>& arr, int k) {
    unordered_map<int, int> counts;
    counts[0] = 1;
    int ans = 0, curr = 0;

    for (int num: arr) {
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç æ¥æ”¹å˜ curr
        ans += counts[curr - k];
        counts[curr]++;
    }

    retu
```
---
### 9. å•è°ƒé€’å¢æ ˆ

```cpp
int fn(vector<int>& arr) {
    stack<integer> stack;
    int ans = 0;

    for (int num: arr) {
        // å¯¹äºå•è°ƒé€’å‡çš„æƒ…å†µï¼Œåªéœ€å°† > ç¿»è½¬åˆ° <
        while (!stack.empty() && stack.top() > num) {
            // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
            stack.pop();
        }

        stack.push(num);
    }
}
```
---
### 10. äºŒå‰æ ‘: DFS (é€’å½’)

```cpp
int dfs(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }

    int ans = 0;
    // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
    dfs(root.left);
    dfs(root.right);
    return ans;
}
```
---
### 11. äºŒå‰æ ‘: DFS (è¿­ä»£)

```cpp
int dfs(TreeNode* root) {
    stack<TreeNode*> stack;
    stack.push(root);
    int ans = 0;

    while (!stack.empty()) {
        TreeNode* node = stack.top();
        stack.pop();
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        if (node->left != nullptr) {
            stack.push(node->left);
        }
        if (node->right != nullptr) {
            stack.push(node->right);
        }
    }

    return ans;
}
```
---
### 12. äºŒå‰æ ‘: BFS

```cpp
int fn(TreeNode* root) {
    queue<TreeNode*> queue;
    queue.push(root);
    int ans = 0;

    while (!queue.empty()) {
        int currentLength = queue.size();
        // åšä¸€äº›å½“å‰å±‚çš„æ“ä½œ

        for (int i = 0; i < currentLength; i++) {
            TreeNode* node = queue.front();
            queue.pop();
            // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
            if (node->left != nullptr) {
                queue.push(node->left);
            }
            if (node->right != nullptr) {
                queue.push(node->right);
            }
        }
    }

    return ans;
}
```
---
### 13. å›¾: DFS (é€’å½’)

ä»¥ä¸‹å›¾æ¨¡æ¿å‡è®¾èŠ‚ç‚¹ç¼–å·ä»Â `0`Â åˆ°Â `n - 1`Â ï¼Œå¹¶ä¸”å›¾æ˜¯ä»¥é‚»æ¥è¡¨çš„å½¢å¼ç»™å‡ºçš„ã€‚æ ¹æ®é—®é¢˜çš„ä¸åŒï¼Œæ‚¨å¯èƒ½éœ€è¦åœ¨ä½¿ç”¨æ¨¡æ¿ä¹‹å‰å°†è¾“å…¥è½¬æ¢ä¸ºç­‰æ•ˆçš„é‚»æ¥è¡¨ã€‚
```cpp
unordered_set<int> seen;

int fn(vector<vector<int>>& graph) {
    seen.insert(START_NODE);
    return dfs(START_NODE, graph);
}

int fn dfs(int node, vector<vector<int>>& graph) {
    int ans = 0;
    // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
    for (int neighbor: graph[node]) {
        if (seen.find(neighbor) == seen.end()) {
            seen.insert(neighbor);
            ans += dfs(neighbor, graph);
        }
    }

    return ans;
}
```
---
### 14. å›¾: DFS (è¿­ä»£)

```cpp
int fn(vector<vector<int>>& graph) {
    stack<int> stack;
    unordered_set<int> seen;
    stack.push(START_NODE);
    seen.insert(START_NODE);
    int ans = 0;

    while (!stack.empty()) {
        int node = stack.top();
        stack.pop();
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        for (int neighbor: graph[node]) {
            if (seen.find(neighbor) == seen.end()) {
                seen.insert(neighbor);
                stack.push(neighbor);
            }
        }
    }
}
```
---
### 15. å›¾: BFS

```cpp
int fn(vector<vector<int>>& graph) {
    queue<int> queue;
    unordered_set<int> seen;
    queue.add(START_NODE);
    seen.insert(START_NODE);
    int ans = 0;

    while (!queue.empty()) {
        int node = queue.front();
        queue.pop();
        // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
        for (int neighbor: graph[node]) {
            if (seen.find(neighbor) == seen.end()) {
                seen.insert(neighbor);
                queue.push(neighbor);
            }
        }
    }
}
```
---
### 16. æ‰¾åˆ°å †çš„å‰ k ä¸ªå…ƒç´ 

```cpp
public int[] fn(int[] arr, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>(CRITERIA);
    for (int num: arr) {
        heap.add(num);
        if (heap.size() > k) {
            heap.remove();
        }
    }

    int[] ans = new int[k];
    for (int i = 0; i < k; i++) {
        ans[i] = heap.remove();
    }

    return ans;
}
```
---
### 17. äºŒåˆ†æŸ¥æ‰¾

```cpp
int binarySearch(vector<int>& arr, int target) {
        int left = 0;
        int right = int(arr.size()) - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                // æ ¹æ®é¢˜æ„è¡¥å……ä»£ç 
                return mid;
            }
            if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // left æ˜¯æ’å…¥ç‚¹
        return left;
}
```
---
### 18. äºŒåˆ†æŸ¥æ‰¾: é‡å¤å…ƒç´ ï¼Œæœ€å·¦è¾¹çš„æ’å…¥ç‚¹

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] >= target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}
```
---
### 19. äºŒåˆ†æŸ¥æ‰¾: é‡å¤å…ƒç´ ï¼Œæœ€å³è¾¹çš„æ’å…¥ç‚¹

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] > target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}
```
---
### 20. äºŒåˆ†æŸ¥æ‰¾: è´ªå¿ƒé—®é¢˜

å¯»æ‰¾æœ€å°å€¼ï¼š
```cpp
int fn(vector<int>& arr) {
    int left = MINIMUM_POSSIBLE_ANSWER;
    int right = MAXIMUM_POSSIBLE_ANSWER;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

bool check(int x) {
    // è¿™ä¸ªå‡½æ•°çš„å…·ä½“å®ç°å–å†³äºé—®é¢˜
    return BOOLEAN;
}
```
å¯»æ‰¾æœ€å¤§å€¼ï¼š
```cpp
int fn(vector<int>& arr) {
    int left = MINIMUM_POSSIBLE_ANSWER;
    int right = MAXIMUM_POSSIBLE_ANSWER;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return right;
}

bool check(int x) {
    // è¿™ä¸ªå‡½æ•°çš„å…·ä½“å®ç°å–å†³äºé—®é¢˜
    return BOOLEAN;
}
```
---
### 21. å›æº¯

```cpp
int backtrack(STATE curr, OTHER_ARGUMENTS...) {
    if (BASE_CASE) {
        // ä¿®æ”¹ç­”æ¡ˆ
        return 0;
    }

    int ans = 0;
    for (ITERATE_OVER_INPUT) {
        // ä¿®æ”¹å½“å‰çŠ¶æ€
        ans += backtrack(curr, OTHER_ARGUMENTS...)
        // æ’¤æ¶ˆå¯¹å½“å‰çŠ¶æ€çš„ä¿®æ”¹
    }

    return ans;
}
```
---
### 22. åŠ¨æ€è§„åˆ’: è‡ªé¡¶å‘ä¸‹æ³•

```cpp
unordered_map<STATE, int> memo;

int fn(vector<int>& arr) {
    return dp(STATE_FOR_WHOLE_INPUT, arr);
}

int dp(STATE, vector<int>& arr) {
    if (BASE_CASE) {
        return 0;
    }

    if (memo.find(STATE) != memo.end()) {
        return memo[STATE];
    }

    int ans = RECURRENCE_RELATION(STATE);
    memo[STATE] = ans;
    return ans;
}
```
---
### 23. æ„å»ºå‰ç¼€æ ‘ï¼ˆå­—å…¸æ ‘ï¼‰

```cpp
// æ³¨æ„:åªæœ‰éœ€è¦åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šå­˜å‚¨æ•°æ®æ—¶æ‰éœ€è¦ä½¿ç”¨ç±»ã€‚
// å¦åˆ™ï¼Œæ‚¨å¯ä»¥åªä½¿ç”¨å“ˆå¸Œæ˜ å°„å®ç°ä¸€ä¸ªå‰ç¼€æ ‘ã€‚
struct TrieNode {
    int data;
    unordered_map<char, TrieNode*> children;
    TrieNode() : data(0), children(unordered_map<char, TrieNode*>()) {}
};

TrieNode* buildTrie(vector<string> words) {
    TrieNode* root = new TrieNode();
    for (string word: words) {
        TrieNode* curr = root;
        for (char c: word) {
            if (curr->children.find(c) == curr->children.end()) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
            // è¿™ä¸ªä½ç½®ä¸Šçš„ curr å·²ç»æœ‰ä¸€ä¸ªå®Œæ•´çš„å•è¯
            // å¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œæ›´å¤šçš„æ“ä½œæ¥ç»™ curr æ·»åŠ å±æ€§
        }
    }

    return root;
}
```