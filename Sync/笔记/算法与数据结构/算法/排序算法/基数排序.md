---
dg-publish: true
---
想一下我们是怎么对日期进行排序的。比如对这样三个日期进行排序：2014 年 1 月 7 日，2020 年 1 月 9 日，2020 年 7 月 10 日。

我们大脑中对日期排序的思维过程是：
- 先看年份，2014 比 2020 要小，所以 2014 年这个日期应该放在其他两个日期前面。
- 另外两个日期年份相等，所以我们比较一下月份，1 比 7 要小，所以 1 月这个日期应该放在 7 月这个日期前面

这种利用多关键字进行排序的思想就是基数排序，和计数排序一样，这也是一种线性时间复杂度的排序算法。其中的每个关键字都被称作一个基数。

比如我们对 999,997,866,666 这四个数字进行基数排序，过程如下：
- 先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系
- 再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系
- 再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999基数排序有两种实现方式。本例属于「最高位优先法」，简称 MSD (Most significant digital)，思路是从最高位开始，依次对基数进行排序。

基数排序有两种实现方式。本例属于「最高位优先法」，简称 `MSD (Most significant digital)`，思路是从最高位开始，依次对基数进行排序。

与之对应的是「最低位优先法」，简称 LSD (Least significant digital)。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。

通常来讲，LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。

但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。

基数排序最早是用在卡片排序机上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 LSD 的基数排序。

动图演示
简单起见，我们先只考虑对非负整数排序的情况。



基数排序可以分为以下三个步骤：

- 找出数组中最大的数字的位数 maxDigitLength
- 获取数组中每个数字的基数
- 遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序
### 找出数组中最大的数字的位数
首先找到数组中的最大值：

```Java
Public static void radixSort (int[] arr) {
    If (arr == null) return;
    Int max = 0;
    For (int value : arr) {
        If (value > max) {
            Max = value;
        }
    }
    // ...
}
```
通过遍历一次数组，找到了数组中的最大值 max，然后我们计算这个最大值的位数：

```Java
Int maxDigitLength = 0;
While (max != 0) {
    MaxDigitLength++;
    Max /= 10;
}
```
将 maxDigitLength 初始化为 0，然后不断地除以 10，每除一次，maxDigitLength 就加一，直到 max 为 0。

读者可能会有疑惑，如果 max 初始值就是 0 呢？严格来讲，0 在数学上属于 1 位数。

但实际上，基数排序时我们无需考虑 max 为 0 的场景，因为 max 为 0 只有一种可能，那就是数组中所有的数字都为 0，此时数组已经有序，我们无需再进行后续的排序过程。

### 获取基数
获取基数有两种做法：

第一种：

```Java
Int mod = 10;
Int dev = 1;
For (int i = 0; i < maxDigitLength; i++) {
    For (int value : arr) {
        Int radix = value % mod / dev;
        // 对基数进行排序
    }
    Mod *= 10;
    Dev *= 10;
}
```
第二种：

```Java
Int dev = 1;
For (int i = 0; i < maxDigitLength; i++) {
    For (int value : arr) {
        Int radix = value / dev % 10;
        // 对基数进行排序
    }
    Dev *= 10;
}
```
两者的区别是先做除法运算还是先做模运算，推荐使用第二种写法，因为它可以节省一个变量。

### 对基数进行排序
对基数进行排序非常适合使用我们在上一节中学习的计数排序算法，因为每一个基数都在 `[0,9]` 之间，并且计数排序是一种稳定的算法。

LSD 方式的基数排序代码如下：


```java
Public class RadixSort {

    public static void radixSort(int[] arr) {
        if (arr == null) return;
        // 找出最大值
        int max = 0;
        for (int value : arr) {
            if (value > max) {
                max = value;
            }
        }
        // 计算最大数字的长度
        int maxDigitLength = 0;
        while (max != 0) {
            maxDigitLength++;
            max /= 10;
        }
        // 使用计数排序算法对基数进行排序
        int[] counting = new int[10];
        int[] result = new int[arr.length];
        int dev = 1;
        for (int i = 0; i < maxDigitLength; i++) {
            for (int value : arr) {
                int radix = value / dev % 10;
                counting[radix]++;
            }
            for (int j = 1; j < counting.length; j++) {
                counting[j] += counting[j - 1];
            }
            // 使用倒序遍历的方式完成计数排序
            for (int j = arr.length - 1; j >= 0; j--) {
                int radix = arr[j] / dev % 10;
                result[--counting[radix]] = arr[j];
            }
            // 计数排序完成后，将结果拷贝回 arr 数组
            System.arraycopy(result, 0, arr, 0, arr.length);
            // 将计数数组重置为 0
            Arrays.fill(counting, 0);
            dev *= 10;
        }
    }
}
```
计数排序的思想上一节已经介绍过，这里不再赘述。当每一轮对基数完成排序后，我们将 result 数组的值拷贝回 arr 数组，并且将 counting 数组中的元素都置为 0，以便在下一轮中复用。

### 对包含负数的数组进行基数排序
如果数组中包含负数，如何进行基数排序呢？

我们很容易想到一种思路：将数组中的每个元素都加上一个合适的正整数，使其全部变成非负整数，等到排序完成后，再减去之前加的这个数就可以了。

但这种方案有一个缺点：加法运算可能导致数字越界，所以必须单独处理数字越界的情况。

事实上，有一种更好的方案解决负数的基数排序。那就是在对基数进行计数排序时，申请长度为 19 的计数数组，用来存储` [−9,9] `这个区间内的所有整数。在把每一位基数计算出来后，加上9，就能对应上 counting 数组的下标了。也就是说，counting 数组的下标` [0,18] `对应基数`[−9,9]`。

代码如下：

```Java
Public class RadixSort {

    public static void radixSort(int[] arr) {
        if (arr == null) return;
        // 找出最长的数
        int max = 0;
        for (int value : arr) {
            if (Math.abs(value) > max) {
                max = Math.abs(value);
            }
        }
        // 计算最长数字的长度
        int maxDigitLength = 0;
        while (max != 0) {
            maxDigitLength++;
            max /= 10;
        }
        // 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]
        int[] counting = new int[19];
        int[] result = new int[arr.length];
        int dev = 1;
        for (int i = 0; i < maxDigitLength; i++) {
            for (int value : arr) {
                // 下标调整
                int radix = value / dev % 10 + 9;
                counting[radix]++;
            }
            for (int j = 1; j < counting.length; j++) {
                counting[j] += counting[j - 1];
            }
            // 使用倒序遍历的方式完成计数排序
            for (int j = arr.length - 1; j >= 0; j--) {
                // 下标调整
                int radix = arr[j] / dev % 10 + 9;
                result[--counting[radix]] = arr[j];
            }
            // 计数排序完成后，将结果拷贝回 arr 数组
            System.arraycopy(result, 0, arr, 0, arr.length);
            // 将计数数组重置为 0
            Arrays.fill(counting, 0);
            dev *= 10;
        }
    }
}
```
代码中主要做了两处修改：

当数组中存在负数时，我们就不能简单的计算数组的最大值了，而是要计算数组中绝对值最大的数，也就是数组中最长的数
在获取基数的步骤，将计算出的基数加上 9，使其与 counting 数组下标一一对应
### LSD VS MSD
前文介绍的基数排序都属于 LSD，接下来我们看一下基数排序的 MSD 实现。

```Java
Public class RadixSort {

    public static void radixSort(int[] arr) {
        if (arr == null) return;
        // 找到最大值
        int max = 0;
        for (int value : arr) {
            if (Math.abs(value) > max) {
                max = Math.abs(value);
            }
        }
        // 计算最大长度
        int maxDigitLength = 0;
        while (max != 0) {
            maxDigitLength++;
            max /= 10;
        }
        radixSort(arr, 0, arr.length - 1, maxDigitLength);
    }

    // 对 arr 数组中的 [start, end] 区间进行基数排序
    private static void radixSort(int[] arr, int start, int end, int position) {
        if (start == end || position == 0) return;
        // 使用计数排序对基数进行排序
        int[] counting = new int[19];
        int[] result = new int[end - start + 1];
        int dev = (int) Math.pow(10, position - 1);
        for (int i = start; i <= end; i++) {
            // MSD, 从最高位开始
            int radix = arr[i] / dev % 10 + 9;
            counting[radix]++;
        }
        for (int j = 1; j < counting.length; j++) {
            counting[j] += counting[j - 1];
        }
        // 拷贝 counting，用于待会的递归
        int[] countingCopy = new int[counting.length];
        System.arraycopy(counting, 0, countingCopy, 0, counting.length);
        for (int i = end; i >= start; i--) {
            int radix = arr[i] / dev % 10 + 9;
            result[--counting[radix]] = arr[i];
        }
        // 计数排序完成后，将结果拷贝回 arr 数组
        System.arraycopy(result, 0, arr, start, result.length);
        // 对 [start, end] 区间内的每一位基数进行递归排序
        for (int i = 0; i < counting.length; i++) {
            radixSort(arr, i == 0 ? start : start + countingCopy[i - 1], start + countingCopy[i] - 1, position - 1);
        }
    }

}
```
使用 MSD 时，下一轮排序只应该发生在当前轮次基数相等的数字之间，对每一位基数进行递归排序的过程中会产生许多临时变量。

相比 LSD，MSD 的基数排序显得较为复杂。因为我们每次对基数进行排序后，无法将所有的结果一视同仁地进行下一轮排序，否则下一轮排序会破坏本次排序的结果。

### 时间复杂度 & 空间复杂度
无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O (n+k)$ ，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k = 10，如果是对包含负数的数组排序，则 k = 19。

所以基数排序的时间复杂度为 $O (d (n+k))$ (d 表示最长数字的位数，k 表示每个基数可能的取值范围大小)。

使用的空间和计数排序是一样的，空间复杂度为 $O (n+k)$（k 表示每个基数可能的取值范围大小）。